# coding: utf-8

"""
    AssistedInstall

    Assisted installation  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, conbytes, conlist, constr

from typing import List, Optional, Union

from openshift_assisted_service.models.bind_host_params import BindHostParams
from openshift_assisted_service.models.cluster import Cluster
from openshift_assisted_service.models.cluster_create_params import ClusterCreateParams
from openshift_assisted_service.models.cluster_default_config import ClusterDefaultConfig
from openshift_assisted_service.models.completion_params import CompletionParams
from openshift_assisted_service.models.credentials import Credentials
from openshift_assisted_service.models.feature_support_level import FeatureSupportLevel
from openshift_assisted_service.models.get_supported_architectures200_response import GetSupportedArchitectures200Response
from openshift_assisted_service.models.get_supported_features200_response import GetSupportedFeatures200Response
from openshift_assisted_service.models.host import Host
from openshift_assisted_service.models.host_create_params import HostCreateParams
from openshift_assisted_service.models.host_ignition_params import HostIgnitionParams
from openshift_assisted_service.models.host_progress import HostProgress
from openshift_assisted_service.models.host_registration_response import HostRegistrationResponse
from openshift_assisted_service.models.host_update_params import HostUpdateParams
from openshift_assisted_service.models.ignored_validations import IgnoredValidations
from openshift_assisted_service.models.import_cluster_params import ImportClusterParams
from openshift_assisted_service.models.infra_env import InfraEnv
from openshift_assisted_service.models.infra_env_create_params import InfraEnvCreateParams
from openshift_assisted_service.models.infra_env_update_params import InfraEnvUpdateParams
from openshift_assisted_service.models.installer_args_params import InstallerArgsParams
from openshift_assisted_service.models.logs_progress_params import LogsProgressParams
from openshift_assisted_service.models.monitored_operator import MonitoredOperator
from openshift_assisted_service.models.operator_monitor_report import OperatorMonitorReport
from openshift_assisted_service.models.platform_type import PlatformType
from openshift_assisted_service.models.preflight_hardware_requirements import PreflightHardwareRequirements
from openshift_assisted_service.models.presigned_url import PresignedUrl
from openshift_assisted_service.models.step_reply import StepReply
from openshift_assisted_service.models.steps import Steps
from openshift_assisted_service.models.v2_cluster_update_params import V2ClusterUpdateParams

from openshift_assisted_service.api_client import ApiClient
from openshift_assisted_service.api_response import ApiResponse
from openshift_assisted_service.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class InstallerApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def bind_host(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is being bound.")], host_id : Annotated[StrictStr, Field(..., description="The host that is being bound.")], bind_host_params : Annotated[BindHostParams, Field(..., description="The parameters for the host binding.")], **kwargs) -> Host:  # noqa: E501
        """bind_host  # noqa: E501

        Bind host to a cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bind_host(infra_env_id, host_id, bind_host_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is being bound. (required)
        :type infra_env_id: str
        :param host_id: The host that is being bound. (required)
        :type host_id: str
        :param bind_host_params: The parameters for the host binding. (required)
        :type bind_host_params: BindHostParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Host
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the bind_host_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.bind_host_with_http_info(infra_env_id, host_id, bind_host_params, **kwargs)  # noqa: E501

    @validate_arguments
    def bind_host_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is being bound.")], host_id : Annotated[StrictStr, Field(..., description="The host that is being bound.")], bind_host_params : Annotated[BindHostParams, Field(..., description="The parameters for the host binding.")], **kwargs) -> ApiResponse:  # noqa: E501
        """bind_host  # noqa: E501

        Bind host to a cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.bind_host_with_http_info(infra_env_id, host_id, bind_host_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is being bound. (required)
        :type infra_env_id: str
        :param host_id: The host that is being bound. (required)
        :type host_id: str
        :param bind_host_params: The parameters for the host binding. (required)
        :type bind_host_params: BindHostParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Host, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id',
            'bind_host_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bind_host" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['bind_host_params'] is not None:
            _body_params = _params['bind_host_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "Host",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '500': "Error",
            '501': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/bind', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def deregister_infra_env(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env to be deleted.")], **kwargs) -> None:  # noqa: E501
        """deregister_infra_env  # noqa: E501

        Deletes an infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.deregister_infra_env(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env to be deleted. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the deregister_infra_env_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.deregister_infra_env_with_http_info(infra_env_id, **kwargs)  # noqa: E501

    @validate_arguments
    def deregister_infra_env_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env to be deleted.")], **kwargs) -> ApiResponse:  # noqa: E501
        """deregister_infra_env  # noqa: E501

        Deletes an infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.deregister_infra_env_with_http_info(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env to be deleted. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'infra_env_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deregister_infra_env" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def download_minimal_initrd(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that should be retrieved.")], **kwargs) -> bytearray:  # noqa: E501
        """download_minimal_initrd  # noqa: E501

        Get the initial ramdisk for minimal ISO based installations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.download_minimal_initrd(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that should be retrieved. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the download_minimal_initrd_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.download_minimal_initrd_with_http_info(infra_env_id, **kwargs)  # noqa: E501

    @validate_arguments
    def download_minimal_initrd_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that should be retrieved.")], **kwargs) -> ApiResponse:  # noqa: E501
        """download_minimal_initrd  # noqa: E501

        Get the initial ramdisk for minimal ISO based installations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.download_minimal_initrd_with_http_info(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that should be retrieved. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_minimal_initrd" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # authentication setting
        _auth_settings = ['urlAuth', 'userAuth', 'imageAuth']  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '204': None,
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/downloads/minimal-initrd', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_cluster_supported_platforms(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose platform types should be retrieved.")], **kwargs) -> List[PlatformType]:  # noqa: E501
        """get_cluster_supported_platforms  # noqa: E501

        A list of platforms that this cluster can support in its current configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_cluster_supported_platforms(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose platform types should be retrieved. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[PlatformType]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_cluster_supported_platforms_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_cluster_supported_platforms_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_cluster_supported_platforms_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose platform types should be retrieved.")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_cluster_supported_platforms  # noqa: E501

        A list of platforms that this cluster can support in its current configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_cluster_supported_platforms_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose platform types should be retrieved. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[PlatformType], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_supported_platforms" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "List[PlatformType]",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/supported-platforms', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_infra_env(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env to be retrieved.")], **kwargs) -> InfraEnv:  # noqa: E501
        """get_infra_env  # noqa: E501

        Retrieves the details of the infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_infra_env(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env to be retrieved. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InfraEnv
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_infra_env_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_infra_env_with_http_info(infra_env_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_infra_env_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env to be retrieved.")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_infra_env  # noqa: E501

        Retrieves the details of the infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_infra_env_with_http_info(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env to be retrieved. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InfraEnv, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_infra_env" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['imageURLAuth', 'urlAuth', 'userAuth', 'imageAuth', 'agentAuth']  # noqa: E501

        _response_types_map = {
            '200': "InfraEnv",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '500': "Error",
            '501': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_infra_env_download_url(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env to be retrieved.")], **kwargs) -> PresignedUrl:  # noqa: E501
        """get_infra_env_download_url  # noqa: E501

        Creates a new pre-signed image download URL for the infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_infra_env_download_url(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env to be retrieved. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PresignedUrl
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_infra_env_download_url_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_infra_env_download_url_with_http_info(infra_env_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_infra_env_download_url_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env to be retrieved.")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_infra_env_download_url  # noqa: E501

        Creates a new pre-signed image download URL for the infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_infra_env_download_url_with_http_info(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env to be retrieved. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PresignedUrl, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_infra_env_download_url" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "PresignedUrl",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '500': "Error",
            '501': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/downloads/image-url', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_infra_env_presigned_file_url(self, infra_env_id : Annotated[StrictStr, Field(..., description="The file's infra-env.")], file_name : Annotated[StrictStr, Field(..., description="The file to be downloaded.")], ipxe_script_type : Annotated[Optional[StrictStr], Field(description="Specify the script type to be served for iPXE.")] = None, **kwargs) -> PresignedUrl:  # noqa: E501
        """get_infra_env_presigned_file_url  # noqa: E501

        Creates a new pre-signed download URL for the infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_infra_env_presigned_file_url(infra_env_id, file_name, ipxe_script_type, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The file's infra-env. (required)
        :type infra_env_id: str
        :param file_name: The file to be downloaded. (required)
        :type file_name: str
        :param ipxe_script_type: Specify the script type to be served for iPXE.
        :type ipxe_script_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PresignedUrl
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_infra_env_presigned_file_url_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_infra_env_presigned_file_url_with_http_info(infra_env_id, file_name, ipxe_script_type, **kwargs)  # noqa: E501

    @validate_arguments
    def get_infra_env_presigned_file_url_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The file's infra-env.")], file_name : Annotated[StrictStr, Field(..., description="The file to be downloaded.")], ipxe_script_type : Annotated[Optional[StrictStr], Field(description="Specify the script type to be served for iPXE.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_infra_env_presigned_file_url  # noqa: E501

        Creates a new pre-signed download URL for the infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_infra_env_presigned_file_url_with_http_info(infra_env_id, file_name, ipxe_script_type, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The file's infra-env. (required)
        :type infra_env_id: str
        :param file_name: The file to be downloaded. (required)
        :type file_name: str
        :param ipxe_script_type: Specify the script type to be served for iPXE.
        :type ipxe_script_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PresignedUrl, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'file_name',
            'ipxe_script_type'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_infra_env_presigned_file_url" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']


        # process the query parameters
        _query_params = []
        if _params.get('file_name') is not None:  # noqa: E501
            _query_params.append(('file_name', _params['file_name']))

        if _params.get('ipxe_script_type') is not None:  # noqa: E501
            _query_params.append(('ipxe_script_type', _params['ipxe_script_type']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "PresignedUrl",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '500': "Error",
            '501': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/downloads/files-presigned', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_supported_architectures(self, openshift_version : Annotated[StrictStr, Field(..., description="Version of the OpenShift cluster.")], **kwargs) -> GetSupportedArchitectures200Response:  # noqa: E501
        """get_supported_architectures  # noqa: E501

        Retrieves the architecture support-levels for each OpenShift version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_supported_architectures(openshift_version, async_req=True)
        >>> result = thread.get()

        :param openshift_version: Version of the OpenShift cluster. (required)
        :type openshift_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetSupportedArchitectures200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_supported_architectures_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_supported_architectures_with_http_info(openshift_version, **kwargs)  # noqa: E501

    @validate_arguments
    def get_supported_architectures_with_http_info(self, openshift_version : Annotated[StrictStr, Field(..., description="Version of the OpenShift cluster.")], **kwargs) -> ApiResponse:  # noqa: E501
        """get_supported_architectures  # noqa: E501

        Retrieves the architecture support-levels for each OpenShift version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_supported_architectures_with_http_info(openshift_version, async_req=True)
        >>> result = thread.get()

        :param openshift_version: Version of the OpenShift cluster. (required)
        :type openshift_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetSupportedArchitectures200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'openshift_version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_supported_architectures" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('openshift_version') is not None:  # noqa: E501
            _query_params.append(('openshift_version', _params['openshift_version']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "GetSupportedArchitectures200Response",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/support-levels/architectures', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_supported_features(self, openshift_version : Annotated[StrictStr, Field(..., description="Version of the OpenShift cluster.")], cpu_architecture : Annotated[Optional[StrictStr], Field(description="The CPU architecture of the image (x86_64/arm64/etc).")] = None, **kwargs) -> GetSupportedFeatures200Response:  # noqa: E501
        """get_supported_features  # noqa: E501

        Retrieves the features support levels for each OpenShift version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_supported_features(openshift_version, cpu_architecture, async_req=True)
        >>> result = thread.get()

        :param openshift_version: Version of the OpenShift cluster. (required)
        :type openshift_version: str
        :param cpu_architecture: The CPU architecture of the image (x86_64/arm64/etc).
        :type cpu_architecture: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetSupportedFeatures200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_supported_features_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_supported_features_with_http_info(openshift_version, cpu_architecture, **kwargs)  # noqa: E501

    @validate_arguments
    def get_supported_features_with_http_info(self, openshift_version : Annotated[StrictStr, Field(..., description="Version of the OpenShift cluster.")], cpu_architecture : Annotated[Optional[StrictStr], Field(description="The CPU architecture of the image (x86_64/arm64/etc).")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """get_supported_features  # noqa: E501

        Retrieves the features support levels for each OpenShift version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_supported_features_with_http_info(openshift_version, cpu_architecture, async_req=True)
        >>> result = thread.get()

        :param openshift_version: Version of the OpenShift cluster. (required)
        :type openshift_version: str
        :param cpu_architecture: The CPU architecture of the image (x86_64/arm64/etc).
        :type cpu_architecture: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetSupportedFeatures200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'openshift_version',
            'cpu_architecture'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_supported_features" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('openshift_version') is not None:  # noqa: E501
            _query_params.append(('openshift_version', _params['openshift_version']))

        if _params.get('cpu_architecture') is not None:  # noqa: E501
            _query_params.append(('cpu_architecture', _params['cpu_architecture']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "GetSupportedFeatures200Response",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/support-levels/features', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_cluster_hosts(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose hosts should be retrieved.")], role : Annotated[Optional[StrictStr], Field(description="Role to request.")] = None, status : Annotated[Optional[StrictStr], Field(description="Hosts status to request.")] = None, with_inventory : Annotated[Optional[StrictBool], Field(description="If true return the host's inventory.")] = None, with_connectivity : Annotated[Optional[StrictBool], Field(description="If true return the host's connectivity.")] = None, **kwargs) -> List[Host]:  # noqa: E501
        """list_cluster_hosts  # noqa: E501

        Get a list of cluster hosts according to supplied filters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_cluster_hosts(cluster_id, role, status, with_inventory, with_connectivity, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose hosts should be retrieved. (required)
        :type cluster_id: str
        :param role: Role to request.
        :type role: str
        :param status: Hosts status to request.
        :type status: str
        :param with_inventory: If true return the host's inventory.
        :type with_inventory: bool
        :param with_connectivity: If true return the host's connectivity.
        :type with_connectivity: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Host]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_cluster_hosts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_cluster_hosts_with_http_info(cluster_id, role, status, with_inventory, with_connectivity, **kwargs)  # noqa: E501

    @validate_arguments
    def list_cluster_hosts_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose hosts should be retrieved.")], role : Annotated[Optional[StrictStr], Field(description="Role to request.")] = None, status : Annotated[Optional[StrictStr], Field(description="Hosts status to request.")] = None, with_inventory : Annotated[Optional[StrictBool], Field(description="If true return the host's inventory.")] = None, with_connectivity : Annotated[Optional[StrictBool], Field(description="If true return the host's connectivity.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """list_cluster_hosts  # noqa: E501

        Get a list of cluster hosts according to supplied filters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_cluster_hosts_with_http_info(cluster_id, role, status, with_inventory, with_connectivity, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose hosts should be retrieved. (required)
        :type cluster_id: str
        :param role: Role to request.
        :type role: str
        :param status: Hosts status to request.
        :type status: str
        :param with_inventory: If true return the host's inventory.
        :type with_inventory: bool
        :param with_connectivity: If true return the host's connectivity.
        :type with_connectivity: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Host], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'role',
            'status',
            'with_inventory',
            'with_connectivity'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_cluster_hosts" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        if _params.get('role') is not None:  # noqa: E501
            _query_params.append(('role', _params['role']))

        if _params.get('status') is not None:  # noqa: E501
            _query_params.append(('status', _params['status']))

        if _params.get('with_inventory') is not None:  # noqa: E501
            _query_params.append(('with-inventory', _params['with_inventory']))

        if _params.get('with_connectivity') is not None:  # noqa: E501
            _query_params.append(('with-connectivity', _params['with_connectivity']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth', 'agentAuth']  # noqa: E501

        _response_types_map = {
            '200': "List[Host]",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/hosts', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def list_infra_envs(self, cluster_id : Annotated[Optional[StrictStr], Field(description="If provided, returns only infra-envs which directly reference this cluster.")] = None, owner : Annotated[Optional[StrictStr], Field(description="If provided, returns only infra-envs that are owned by the specified user.")] = None, **kwargs) -> List[InfraEnv]:  # noqa: E501
        """list_infra_envs  # noqa: E501

        Retrieves the list of infra-envs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_infra_envs(cluster_id, owner, async_req=True)
        >>> result = thread.get()

        :param cluster_id: If provided, returns only infra-envs which directly reference this cluster.
        :type cluster_id: str
        :param owner: If provided, returns only infra-envs that are owned by the specified user.
        :type owner: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[InfraEnv]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_infra_envs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_infra_envs_with_http_info(cluster_id, owner, **kwargs)  # noqa: E501

    @validate_arguments
    def list_infra_envs_with_http_info(self, cluster_id : Annotated[Optional[StrictStr], Field(description="If provided, returns only infra-envs which directly reference this cluster.")] = None, owner : Annotated[Optional[StrictStr], Field(description="If provided, returns only infra-envs that are owned by the specified user.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """list_infra_envs  # noqa: E501

        Retrieves the list of infra-envs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_infra_envs_with_http_info(cluster_id, owner, async_req=True)
        >>> result = thread.get()

        :param cluster_id: If provided, returns only infra-envs which directly reference this cluster.
        :type cluster_id: str
        :param owner: If provided, returns only infra-envs that are owned by the specified user.
        :type owner: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[InfraEnv], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'owner'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_infra_envs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('cluster_id') is not None:  # noqa: E501
            _query_params.append(('cluster_id', _params['cluster_id']))

        if _params.get('owner') is not None:  # noqa: E501
            _query_params.append(('owner', _params['owner']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "List[InfraEnv]",
            '401': "InfraError",
            '403': "InfraError",
            '405': "Error",
            '500': "Error",
            '501': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def regenerate_infra_env_signing_key(self, infra_env_id : Annotated[StrictStr, Field(..., description="The target InfraEnv.")], **kwargs) -> None:  # noqa: E501
        """regenerate_infra_env_signing_key  # noqa: E501

        Regenerate InfraEnv token signing key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.regenerate_infra_env_signing_key(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The target InfraEnv. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the regenerate_infra_env_signing_key_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.regenerate_infra_env_signing_key_with_http_info(infra_env_id, **kwargs)  # noqa: E501

    @validate_arguments
    def regenerate_infra_env_signing_key_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The target InfraEnv.")], **kwargs) -> ApiResponse:  # noqa: E501
        """regenerate_infra_env_signing_key  # noqa: E501

        Regenerate InfraEnv token signing key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.regenerate_infra_env_signing_key_with_http_info(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The target InfraEnv. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'infra_env_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method regenerate_infra_env_signing_key" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/regenerate-signing-key', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def register_infra_env(self, infraenv_create_params : Annotated[InfraEnvCreateParams, Field(..., description="The parameters for the generated ISO.")], **kwargs) -> InfraEnv:  # noqa: E501
        """register_infra_env  # noqa: E501

        Creates a new OpenShift Discovery ISO.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_infra_env(infraenv_create_params, async_req=True)
        >>> result = thread.get()

        :param infraenv_create_params: The parameters for the generated ISO. (required)
        :type infraenv_create_params: InfraEnvCreateParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InfraEnv
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the register_infra_env_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.register_infra_env_with_http_info(infraenv_create_params, **kwargs)  # noqa: E501

    @validate_arguments
    def register_infra_env_with_http_info(self, infraenv_create_params : Annotated[InfraEnvCreateParams, Field(..., description="The parameters for the generated ISO.")], **kwargs) -> ApiResponse:  # noqa: E501
        """register_infra_env  # noqa: E501

        Creates a new OpenShift Discovery ISO.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_infra_env_with_http_info(infraenv_create_params, async_req=True)
        >>> result = thread.get()

        :param infraenv_create_params: The parameters for the generated ISO. (required)
        :type infraenv_create_params: InfraEnvCreateParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InfraEnv, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infraenv_create_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_infra_env" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['infraenv_create_params'] is not None:
            _body_params = _params['infraenv_create_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '201': "InfraEnv",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
            '501': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def transform_cluster_to_adding_hosts(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to transform.")], **kwargs) -> Cluster:  # noqa: E501
        """transform_cluster_to_adding_hosts  # noqa: E501

        Transforms installed cluster to a state which allows adding hosts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.transform_cluster_to_adding_hosts(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to transform. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cluster
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the transform_cluster_to_adding_hosts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.transform_cluster_to_adding_hosts_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def transform_cluster_to_adding_hosts_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to transform.")], **kwargs) -> ApiResponse:  # noqa: E501
        """transform_cluster_to_adding_hosts  # noqa: E501

        Transforms installed cluster to a state which allows adding hosts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.transform_cluster_to_adding_hosts_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to transform. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cluster, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transform_cluster_to_adding_hosts" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '202': "Cluster",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/actions/allow-add-hosts', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def transform_cluster_to_day2(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to transform.")], **kwargs) -> Cluster:  # noqa: E501
        """(Deprecated) transform_cluster_to_day2  # noqa: E501

        Deprecated, maintained for legacy purposes. Does the same thing as allow-add-hosts. Use allow-add-hosts instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.transform_cluster_to_day2(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to transform. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cluster
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the transform_cluster_to_day2_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.transform_cluster_to_day2_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def transform_cluster_to_day2_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to transform.")], **kwargs) -> ApiResponse:  # noqa: E501
        """(Deprecated) transform_cluster_to_day2  # noqa: E501

        Deprecated, maintained for legacy purposes. Does the same thing as allow-add-hosts. Use allow-add-hosts instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.transform_cluster_to_day2_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to transform. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cluster, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn("POST /v2/clusters/{cluster_id}/actions/allow-add-workers is deprecated.", DeprecationWarning)

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transform_cluster_to_day2" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '202': "Cluster",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/actions/allow-add-workers', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def unbind_host(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is being bound.")], host_id : Annotated[StrictStr, Field(..., description="The host that is being bound.")], **kwargs) -> Host:  # noqa: E501
        """unbind_host  # noqa: E501

        Unbind host to a cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.unbind_host(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is being bound. (required)
        :type infra_env_id: str
        :param host_id: The host that is being bound. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Host
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the unbind_host_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.unbind_host_with_http_info(infra_env_id, host_id, **kwargs)  # noqa: E501

    @validate_arguments
    def unbind_host_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is being bound.")], host_id : Annotated[StrictStr, Field(..., description="The host that is being bound.")], **kwargs) -> ApiResponse:  # noqa: E501
        """unbind_host  # noqa: E501

        Unbind host to a cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.unbind_host_with_http_info(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is being bound. (required)
        :type infra_env_id: str
        :param host_id: The host that is being bound. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Host, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unbind_host" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "Host",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
            '501': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/unbind', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_infra_env(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env to be updated.")], infra_env_update_params : Annotated[InfraEnvUpdateParams, Field(..., description="The properties to update.")], **kwargs) -> InfraEnv:  # noqa: E501
        """update_infra_env  # noqa: E501

        Updates an infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_infra_env(infra_env_id, infra_env_update_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env to be updated. (required)
        :type infra_env_id: str
        :param infra_env_update_params: The properties to update. (required)
        :type infra_env_update_params: InfraEnvUpdateParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InfraEnv
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the update_infra_env_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.update_infra_env_with_http_info(infra_env_id, infra_env_update_params, **kwargs)  # noqa: E501

    @validate_arguments
    def update_infra_env_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env to be updated.")], infra_env_update_params : Annotated[InfraEnvUpdateParams, Field(..., description="The properties to update.")], **kwargs) -> ApiResponse:  # noqa: E501
        """update_infra_env  # noqa: E501

        Updates an infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_infra_env_with_http_info(infra_env_id, infra_env_update_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env to be updated. (required)
        :type infra_env_id: str
        :param infra_env_update_params: The properties to update. (required)
        :type infra_env_update_params: InfraEnvUpdateParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InfraEnv, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'infra_env_update_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_infra_env" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['infra_env_update_params'] is not None:
            _body_params = _params['infra_env_update_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '201': "InfraEnv",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
            '501': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_cancel_installation(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose installation is to be canceled.")], **kwargs) -> Cluster:  # noqa: E501
        """v2_cancel_installation  # noqa: E501

        Cancels an ongoing installation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_cancel_installation(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose installation is to be canceled. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cluster
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_cancel_installation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_cancel_installation_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_cancel_installation_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose installation is to be canceled.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_cancel_installation  # noqa: E501

        Cancels an ongoing installation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_cancel_installation_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose installation is to be canceled. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cluster, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_cancel_installation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '202': "Cluster",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/actions/cancel', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_complete_installation(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose installation is being completing.")], completion_params : Annotated[CompletionParams, Field(..., description="The final status of the cluster installation.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is completing the installation.")] = None, **kwargs) -> Cluster:  # noqa: E501
        """v2_complete_installation  # noqa: E501

        Agent API to mark a finalizing installation as complete and progress to 100%.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_complete_installation(cluster_id, completion_params, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose installation is being completing. (required)
        :type cluster_id: str
        :param completion_params: The final status of the cluster installation. (required)
        :type completion_params: CompletionParams
        :param discovery_agent_version: The software version of the discovery agent that is completing the installation.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cluster
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_complete_installation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_complete_installation_with_http_info(cluster_id, completion_params, discovery_agent_version, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_complete_installation_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose installation is being completing.")], completion_params : Annotated[CompletionParams, Field(..., description="The final status of the cluster installation.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is completing the installation.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_complete_installation  # noqa: E501

        Agent API to mark a finalizing installation as complete and progress to 100%.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_complete_installation_with_http_info(cluster_id, completion_params, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose installation is being completing. (required)
        :type cluster_id: str
        :param completion_params: The final status of the cluster installation. (required)
        :type completion_params: CompletionParams
        :param discovery_agent_version: The software version of the discovery agent that is completing the installation.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cluster, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'completion_params',
            'discovery_agent_version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_complete_installation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['discovery_agent_version']:
            _header_params['discovery_agent_version'] = _params['discovery_agent_version']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['completion_params'] is not None:
            _body_params = _params['completion_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['agentAuth']  # noqa: E501

        _response_types_map = {
            '202': "Cluster",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/actions/complete-installation', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_deregister_cluster(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to be deregistered.")], **kwargs) -> None:  # noqa: E501
        """v2_deregister_cluster  # noqa: E501

        Deletes an OpenShift cluster definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_deregister_cluster(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to be deregistered. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_deregister_cluster_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_deregister_cluster_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_deregister_cluster_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to be deregistered.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_deregister_cluster  # noqa: E501

        Deletes an OpenShift cluster definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_deregister_cluster_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to be deregistered. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_deregister_cluster" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_deregister_host(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that should be deregistered.")], host_id : Annotated[StrictStr, Field(..., description="The host that should be deregistered.")], **kwargs) -> None:  # noqa: E501
        """v2_deregister_host  # noqa: E501

        Deregisters an OpenShift host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_deregister_host(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that should be deregistered. (required)
        :type infra_env_id: str
        :param host_id: The host that should be deregistered. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_deregister_host_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_deregister_host_with_http_info(infra_env_id, host_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_deregister_host_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that should be deregistered.")], host_id : Annotated[StrictStr, Field(..., description="The host that should be deregistered.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_deregister_host  # noqa: E501

        Deregisters an OpenShift host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_deregister_host_with_http_info(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that should be deregistered. (required)
        :type infra_env_id: str
        :param host_id: The host that should be deregistered. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_deregister_host" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_download_cluster_credentials(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster that owns the credential file that should be downloaded.")], file_name : Annotated[StrictStr, Field(..., description="The credential file to be downloaded.")], **kwargs) -> bytearray:  # noqa: E501
        """v2_download_cluster_credentials  # noqa: E501

        Downloads credentials relating to the installed/installing cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_download_cluster_credentials(cluster_id, file_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster that owns the credential file that should be downloaded. (required)
        :type cluster_id: str
        :param file_name: The credential file to be downloaded. (required)
        :type file_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_download_cluster_credentials_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_download_cluster_credentials_with_http_info(cluster_id, file_name, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_download_cluster_credentials_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster that owns the credential file that should be downloaded.")], file_name : Annotated[StrictStr, Field(..., description="The credential file to be downloaded.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_download_cluster_credentials  # noqa: E501

        Downloads credentials relating to the installed/installing cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_download_cluster_credentials_with_http_info(cluster_id, file_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster that owns the credential file that should be downloaded. (required)
        :type cluster_id: str
        :param file_name: The credential file to be downloaded. (required)
        :type file_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'file_name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_download_cluster_credentials" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        if _params.get('file_name') is not None:  # noqa: E501
            _query_params.append(('file_name', _params['file_name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # authentication setting
        _auth_settings = ['urlAuth', 'userAuth', 'agentAuth']  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/downloads/credentials', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_download_cluster_files(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster that owns the file that should be downloaded.")], file_name : Annotated[StrictStr, Field(..., description="The file to be downloaded.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is downloading the file.")] = None, **kwargs) -> bytearray:  # noqa: E501
        """v2_download_cluster_files  # noqa: E501

        Downloads files relating to the installed/installing cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_download_cluster_files(cluster_id, file_name, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster that owns the file that should be downloaded. (required)
        :type cluster_id: str
        :param file_name: The file to be downloaded. (required)
        :type file_name: str
        :param discovery_agent_version: The software version of the discovery agent that is downloading the file.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_download_cluster_files_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_download_cluster_files_with_http_info(cluster_id, file_name, discovery_agent_version, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_download_cluster_files_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster that owns the file that should be downloaded.")], file_name : Annotated[StrictStr, Field(..., description="The file to be downloaded.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is downloading the file.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_download_cluster_files  # noqa: E501

        Downloads files relating to the installed/installing cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_download_cluster_files_with_http_info(cluster_id, file_name, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster that owns the file that should be downloaded. (required)
        :type cluster_id: str
        :param file_name: The file to be downloaded. (required)
        :type file_name: str
        :param discovery_agent_version: The software version of the discovery agent that is downloading the file.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'file_name',
            'discovery_agent_version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_download_cluster_files" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        if _params.get('file_name') is not None:  # noqa: E501
            _query_params.append(('file_name', _params['file_name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['discovery_agent_version']:
            _header_params['discovery_agent_version'] = _params['discovery_agent_version']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # authentication setting
        _auth_settings = ['urlAuth', 'userAuth', 'agentAuth']  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/downloads/files', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_download_cluster_logs(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose logs should be downloaded.")], logs_type : Annotated[Optional[StrictStr], Field(description="The type of logs to be downloaded.")] = None, host_id : Annotated[Optional[StrictStr], Field(description="A specific host in the cluster whose logs should be downloaded.")] = None, **kwargs) -> bytearray:  # noqa: E501
        """v2_download_cluster_logs  # noqa: E501

        Download cluster logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_download_cluster_logs(cluster_id, logs_type, host_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose logs should be downloaded. (required)
        :type cluster_id: str
        :param logs_type: The type of logs to be downloaded.
        :type logs_type: str
        :param host_id: A specific host in the cluster whose logs should be downloaded.
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_download_cluster_logs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_download_cluster_logs_with_http_info(cluster_id, logs_type, host_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_download_cluster_logs_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose logs should be downloaded.")], logs_type : Annotated[Optional[StrictStr], Field(description="The type of logs to be downloaded.")] = None, host_id : Annotated[Optional[StrictStr], Field(description="A specific host in the cluster whose logs should be downloaded.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_download_cluster_logs  # noqa: E501

        Download cluster logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_download_cluster_logs_with_http_info(cluster_id, logs_type, host_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose logs should be downloaded. (required)
        :type cluster_id: str
        :param logs_type: The type of logs to be downloaded.
        :type logs_type: str
        :param host_id: A specific host in the cluster whose logs should be downloaded.
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'logs_type',
            'host_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_download_cluster_logs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        if _params.get('logs_type') is not None:  # noqa: E501
            _query_params.append(('logs_type', _params['logs_type']))

        if _params.get('host_id') is not None:  # noqa: E501
            _query_params.append(('host_id', _params['host_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # authentication setting
        _auth_settings = ['urlAuth', 'userAuth']  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/logs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_download_host_ignition(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host whose ignition file should be downloaded.")], host_id : Annotated[StrictStr, Field(..., description="The host whose ignition file should be downloaded.")], **kwargs) -> bytearray:  # noqa: E501
        """v2_download_host_ignition  # noqa: E501

        Downloads the customized ignition file for this bound host, produces octet stream. For unbound host - error is returned  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_download_host_ignition(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host whose ignition file should be downloaded. (required)
        :type infra_env_id: str
        :param host_id: The host whose ignition file should be downloaded. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_download_host_ignition_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_download_host_ignition_with_http_info(infra_env_id, host_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_download_host_ignition_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host whose ignition file should be downloaded.")], host_id : Annotated[StrictStr, Field(..., description="The host whose ignition file should be downloaded.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_download_host_ignition  # noqa: E501

        Downloads the customized ignition file for this bound host, produces octet stream. For unbound host - error is returned  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_download_host_ignition_with_http_info(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host whose ignition file should be downloaded. (required)
        :type infra_env_id: str
        :param host_id: The host whose ignition file should be downloaded. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_download_host_ignition" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth', 'agentAuth']  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-env/{infra_env_id}/hosts/{host_id}/downloads/ignition', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_download_infra_env_files(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env whose file should be downloaded.")], file_name : Annotated[StrictStr, Field(..., description="The file to be downloaded.")], mac : Annotated[Optional[StrictStr], Field(description="Mac address of the host running ipxe script.")] = None, ipxe_script_type : Annotated[Optional[StrictStr], Field(description="Specify the script type to be served for iPXE.")] = None, discovery_iso_type : Annotated[Optional[StrictStr], Field(description="Overrides the ISO type for the disovery ignition, either 'full-iso' or 'minimal-iso'.")] = None, **kwargs) -> bytearray:  # noqa: E501
        """v2_download_infra_env_files  # noqa: E501

        Downloads the customized ignition file for this host  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_download_infra_env_files(infra_env_id, file_name, mac, ipxe_script_type, discovery_iso_type, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env whose file should be downloaded. (required)
        :type infra_env_id: str
        :param file_name: The file to be downloaded. (required)
        :type file_name: str
        :param mac: Mac address of the host running ipxe script.
        :type mac: str
        :param ipxe_script_type: Specify the script type to be served for iPXE.
        :type ipxe_script_type: str
        :param discovery_iso_type: Overrides the ISO type for the disovery ignition, either 'full-iso' or 'minimal-iso'.
        :type discovery_iso_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_download_infra_env_files_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_download_infra_env_files_with_http_info(infra_env_id, file_name, mac, ipxe_script_type, discovery_iso_type, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_download_infra_env_files_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env whose file should be downloaded.")], file_name : Annotated[StrictStr, Field(..., description="The file to be downloaded.")], mac : Annotated[Optional[StrictStr], Field(description="Mac address of the host running ipxe script.")] = None, ipxe_script_type : Annotated[Optional[StrictStr], Field(description="Specify the script type to be served for iPXE.")] = None, discovery_iso_type : Annotated[Optional[StrictStr], Field(description="Overrides the ISO type for the disovery ignition, either 'full-iso' or 'minimal-iso'.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_download_infra_env_files  # noqa: E501

        Downloads the customized ignition file for this host  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_download_infra_env_files_with_http_info(infra_env_id, file_name, mac, ipxe_script_type, discovery_iso_type, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env whose file should be downloaded. (required)
        :type infra_env_id: str
        :param file_name: The file to be downloaded. (required)
        :type file_name: str
        :param mac: Mac address of the host running ipxe script.
        :type mac: str
        :param ipxe_script_type: Specify the script type to be served for iPXE.
        :type ipxe_script_type: str
        :param discovery_iso_type: Overrides the ISO type for the disovery ignition, either 'full-iso' or 'minimal-iso'.
        :type discovery_iso_type: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'file_name',
            'mac',
            'ipxe_script_type',
            'discovery_iso_type'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_download_infra_env_files" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']


        # process the query parameters
        _query_params = []
        if _params.get('file_name') is not None:  # noqa: E501
            _query_params.append(('file_name', _params['file_name']))

        if _params.get('mac') is not None:  # noqa: E501
            _query_params.append(('mac', _params['mac']))

        if _params.get('ipxe_script_type') is not None:  # noqa: E501
            _query_params.append(('ipxe_script_type', _params['ipxe_script_type']))

        if _params.get('discovery_iso_type') is not None:  # noqa: E501
            _query_params.append(('discovery_iso_type', _params['discovery_iso_type']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/octet-stream'])  # noqa: E501

        # authentication setting
        _auth_settings = ['imageURLAuth', 'urlAuth', 'userAuth', 'imageAuth', 'agentAuth']  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
            '501': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/downloads/files', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_cluster(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to be retrieved.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is retrieving the cluster details.")] = None, get_unregistered_clusters : Annotated[Optional[StrictBool], Field(description="Whether to return clusters that have been unregistered.")] = None, exclude_hosts : Annotated[Optional[StrictBool], Field(description="If true, do not include hosts.")] = None, **kwargs) -> Cluster:  # noqa: E501
        """v2_get_cluster  # noqa: E501

        Retrieves the details of the OpenShift cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_cluster(cluster_id, discovery_agent_version, get_unregistered_clusters, exclude_hosts, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to be retrieved. (required)
        :type cluster_id: str
        :param discovery_agent_version: The software version of the discovery agent that is retrieving the cluster details.
        :type discovery_agent_version: str
        :param get_unregistered_clusters: Whether to return clusters that have been unregistered.
        :type get_unregistered_clusters: bool
        :param exclude_hosts: If true, do not include hosts.
        :type exclude_hosts: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cluster
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_cluster_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_cluster_with_http_info(cluster_id, discovery_agent_version, get_unregistered_clusters, exclude_hosts, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_cluster_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to be retrieved.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is retrieving the cluster details.")] = None, get_unregistered_clusters : Annotated[Optional[StrictBool], Field(description="Whether to return clusters that have been unregistered.")] = None, exclude_hosts : Annotated[Optional[StrictBool], Field(description="If true, do not include hosts.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_cluster  # noqa: E501

        Retrieves the details of the OpenShift cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_cluster_with_http_info(cluster_id, discovery_agent_version, get_unregistered_clusters, exclude_hosts, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to be retrieved. (required)
        :type cluster_id: str
        :param discovery_agent_version: The software version of the discovery agent that is retrieving the cluster details.
        :type discovery_agent_version: str
        :param get_unregistered_clusters: Whether to return clusters that have been unregistered.
        :type get_unregistered_clusters: bool
        :param exclude_hosts: If true, do not include hosts.
        :type exclude_hosts: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cluster, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'discovery_agent_version',
            'get_unregistered_clusters',
            'exclude_hosts'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_cluster" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        if _params.get('exclude_hosts') is not None:  # noqa: E501
            _query_params.append(('exclude-hosts', _params['exclude_hosts']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['discovery_agent_version']:
            _header_params['discovery_agent_version'] = _params['discovery_agent_version']

        if _params['get_unregistered_clusters']:
            _header_params['get_unregistered_clusters'] = _params['get_unregistered_clusters']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth', 'agentAuth']  # noqa: E501

        _response_types_map = {
            '200': "Cluster",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '500': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_cluster_default_config(self, **kwargs) -> ClusterDefaultConfig:  # noqa: E501
        """v2_get_cluster_default_config  # noqa: E501

        Get the default values for various cluster properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_cluster_default_config(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ClusterDefaultConfig
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_cluster_default_config_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_cluster_default_config_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_cluster_default_config_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_cluster_default_config  # noqa: E501

        Get the default values for various cluster properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_cluster_default_config_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ClusterDefaultConfig, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_cluster_default_config" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "ClusterDefaultConfig",
            '401': "InfraError",
            '403': "InfraError",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/default-config', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_cluster_install_config(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose install config is being retrieved.")], **kwargs) -> str:  # noqa: E501
        """v2_get_cluster_install_config  # noqa: E501

        Get the cluster's install config YAML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_cluster_install_config(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose install config is being retrieved. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_cluster_install_config_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_cluster_install_config_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_cluster_install_config_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose install config is being retrieved.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_cluster_install_config  # noqa: E501

        Get the cluster's install config YAML.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_cluster_install_config_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose install config is being retrieved. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_cluster_install_config" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/install-config', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_cluster_ui_settings(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster for which UI settings should be retrieved.")], **kwargs) -> str:  # noqa: E501
        """v2_get_cluster_ui_settings  # noqa: E501

        Fetch cluster specific UI settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_cluster_ui_settings(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster for which UI settings should be retrieved. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_cluster_ui_settings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_cluster_ui_settings_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_cluster_ui_settings_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster for which UI settings should be retrieved.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_cluster_ui_settings  # noqa: E501

        Fetch cluster specific UI settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_cluster_ui_settings_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster for which UI settings should be retrieved. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_cluster_ui_settings" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "Error",
            '404': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/ui-settings', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_credentials(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose admin credentials should be retrieved.")], **kwargs) -> Credentials:  # noqa: E501
        """v2_get_credentials  # noqa: E501

        Get the cluster admin credentials.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_credentials(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose admin credentials should be retrieved. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Credentials
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_credentials_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_credentials_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_credentials_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose admin credentials should be retrieved.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_credentials  # noqa: E501

        Get the cluster admin credentials.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_credentials_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose admin credentials should be retrieved. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Credentials, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_credentials" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "Credentials",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/credentials', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_host(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that should be retrieved.")], host_id : Annotated[StrictStr, Field(..., description="The host that should be retrieved.")], **kwargs) -> Host:  # noqa: E501
        """v2_get_host  # noqa: E501

        Retrieves the details of the OpenShift host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_host(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that should be retrieved. (required)
        :type infra_env_id: str
        :param host_id: The host that should be retrieved. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Host
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_host_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_host_with_http_info(infra_env_id, host_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_host_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that should be retrieved.")], host_id : Annotated[StrictStr, Field(..., description="The host that should be retrieved.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_host  # noqa: E501

        Retrieves the details of the OpenShift host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_host_with_http_info(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that should be retrieved. (required)
        :type infra_env_id: str
        :param host_id: The host that should be retrieved. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Host, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_host" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "Host",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '500': "Error",
            '501': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_host_ignition(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host whose ignition file should be obtained.")], host_id : Annotated[StrictStr, Field(..., description="The host whose ignition file should be obtained.")], **kwargs) -> HostIgnitionParams:  # noqa: E501
        """v2_get_host_ignition  # noqa: E501

        Fetch the ignition file for this host as a string. In case of unbound host produces an error  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_host_ignition(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host whose ignition file should be obtained. (required)
        :type infra_env_id: str
        :param host_id: The host whose ignition file should be obtained. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HostIgnitionParams
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_host_ignition_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_host_ignition_with_http_info(infra_env_id, host_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_host_ignition_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host whose ignition file should be obtained.")], host_id : Annotated[StrictStr, Field(..., description="The host whose ignition file should be obtained.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_host_ignition  # noqa: E501

        Fetch the ignition file for this host as a string. In case of unbound host produces an error  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_host_ignition_with_http_info(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host whose ignition file should be obtained. (required)
        :type infra_env_id: str
        :param host_id: The host whose ignition file should be obtained. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HostIgnitionParams, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_host_ignition" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "HostIgnitionParams",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '500': "Error",
            '501': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/ignition', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_ignored_validations(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose failing validations should be ignored according to this list.")], **kwargs) -> IgnoredValidations:  # noqa: E501
        """v2_get_ignored_validations  # noqa: E501

        Fetch the validations which are to be ignored for this cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_ignored_validations(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose failing validations should be ignored according to this list. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IgnoredValidations
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_ignored_validations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_ignored_validations_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_ignored_validations_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose failing validations should be ignored according to this list.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_ignored_validations  # noqa: E501

        Fetch the validations which are to be ignored for this cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_ignored_validations_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose failing validations should be ignored according to this list. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IgnoredValidations, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_ignored_validations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "IgnoredValidations",
            '400': "Error",
            '404': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/ignored-validations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_next_steps(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is retrieving instructions.")], host_id : Annotated[StrictStr, Field(..., description="The host that is retrieving instructions.")], timestamp : Annotated[Optional[StrictInt], Field(description="The time on the host as seconds since the Unix epoch.")] = None, discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is retrieving instructions.")] = None, **kwargs) -> Steps:  # noqa: E501
        """v2_get_next_steps  # noqa: E501

        Retrieves the next operations that the host agent needs to perform.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_next_steps(infra_env_id, host_id, timestamp, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is retrieving instructions. (required)
        :type infra_env_id: str
        :param host_id: The host that is retrieving instructions. (required)
        :type host_id: str
        :param timestamp: The time on the host as seconds since the Unix epoch.
        :type timestamp: int
        :param discovery_agent_version: The software version of the discovery agent that is retrieving instructions.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Steps
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_next_steps_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_next_steps_with_http_info(infra_env_id, host_id, timestamp, discovery_agent_version, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_next_steps_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is retrieving instructions.")], host_id : Annotated[StrictStr, Field(..., description="The host that is retrieving instructions.")], timestamp : Annotated[Optional[StrictInt], Field(description="The time on the host as seconds since the Unix epoch.")] = None, discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is retrieving instructions.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_next_steps  # noqa: E501

        Retrieves the next operations that the host agent needs to perform.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_next_steps_with_http_info(infra_env_id, host_id, timestamp, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is retrieving instructions. (required)
        :type infra_env_id: str
        :param host_id: The host that is retrieving instructions. (required)
        :type host_id: str
        :param timestamp: The time on the host as seconds since the Unix epoch.
        :type timestamp: int
        :param discovery_agent_version: The software version of the discovery agent that is retrieving instructions.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Steps, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id',
            'timestamp',
            'discovery_agent_version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_next_steps" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        if _params.get('timestamp') is not None:  # noqa: E501
            _query_params.append(('timestamp', _params['timestamp']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['discovery_agent_version']:
            _header_params['discovery_agent_version'] = _params['discovery_agent_version']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['agentAuth']  # noqa: E501

        _response_types_map = {
            '200': "Steps",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '500': "Error",
            '501': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/instructions', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_preflight_requirements(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to return preflight requirements for.")], **kwargs) -> PreflightHardwareRequirements:  # noqa: E501
        """v2_get_preflight_requirements  # noqa: E501

        Get preflight requirements for a cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_preflight_requirements(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to return preflight requirements for. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PreflightHardwareRequirements
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_preflight_requirements_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_preflight_requirements_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_preflight_requirements_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to return preflight requirements for.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_preflight_requirements  # noqa: E501

        Get preflight requirements for a cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_preflight_requirements_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to return preflight requirements for. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PreflightHardwareRequirements, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_preflight_requirements" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "PreflightHardwareRequirements",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/preflight-requirements', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_presigned_for_cluster_credentials(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster that owns the file that should be downloaded.")], file_name : Annotated[StrictStr, Field(..., description="The file to be downloaded.")], **kwargs) -> PresignedUrl:  # noqa: E501
        """v2_get_presigned_for_cluster_credentials  # noqa: E501

        Get the cluster admin credentials.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_presigned_for_cluster_credentials(cluster_id, file_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster that owns the file that should be downloaded. (required)
        :type cluster_id: str
        :param file_name: The file to be downloaded. (required)
        :type file_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PresignedUrl
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_presigned_for_cluster_credentials_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_presigned_for_cluster_credentials_with_http_info(cluster_id, file_name, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_presigned_for_cluster_credentials_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster that owns the file that should be downloaded.")], file_name : Annotated[StrictStr, Field(..., description="The file to be downloaded.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_presigned_for_cluster_credentials  # noqa: E501

        Get the cluster admin credentials.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_presigned_for_cluster_credentials_with_http_info(cluster_id, file_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster that owns the file that should be downloaded. (required)
        :type cluster_id: str
        :param file_name: The file to be downloaded. (required)
        :type file_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PresignedUrl, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'file_name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_presigned_for_cluster_credentials" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        if _params.get('file_name') is not None:  # noqa: E501
            _query_params.append(('file_name', _params['file_name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "PresignedUrl",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/downloads/credentials-presigned', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_get_presigned_for_cluster_files(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster that owns the file that should be downloaded.")], file_name : Annotated[StrictStr, Field(..., description="The file to be downloaded.")], logs_type : Annotated[Optional[StrictStr], Field(description="If downloading logs, the type of logs to download.")] = None, host_id : Annotated[Optional[StrictStr], Field(description="If downloading a file related to a host, the relevant host.")] = None, additional_name : Annotated[Optional[StrictStr], Field(description="If downloading a manifest, the file name, prefaced with folder name, for example, openshift/99-openshift-xyz.yaml.")] = None, **kwargs) -> PresignedUrl:  # noqa: E501
        """v2_get_presigned_for_cluster_files  # noqa: E501

        Retrieves a pre-signed S3 URL for downloading cluster files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_presigned_for_cluster_files(cluster_id, file_name, logs_type, host_id, additional_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster that owns the file that should be downloaded. (required)
        :type cluster_id: str
        :param file_name: The file to be downloaded. (required)
        :type file_name: str
        :param logs_type: If downloading logs, the type of logs to download.
        :type logs_type: str
        :param host_id: If downloading a file related to a host, the relevant host.
        :type host_id: str
        :param additional_name: If downloading a manifest, the file name, prefaced with folder name, for example, openshift/99-openshift-xyz.yaml.
        :type additional_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PresignedUrl
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_get_presigned_for_cluster_files_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_get_presigned_for_cluster_files_with_http_info(cluster_id, file_name, logs_type, host_id, additional_name, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_get_presigned_for_cluster_files_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster that owns the file that should be downloaded.")], file_name : Annotated[StrictStr, Field(..., description="The file to be downloaded.")], logs_type : Annotated[Optional[StrictStr], Field(description="If downloading logs, the type of logs to download.")] = None, host_id : Annotated[Optional[StrictStr], Field(description="If downloading a file related to a host, the relevant host.")] = None, additional_name : Annotated[Optional[StrictStr], Field(description="If downloading a manifest, the file name, prefaced with folder name, for example, openshift/99-openshift-xyz.yaml.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_get_presigned_for_cluster_files  # noqa: E501

        Retrieves a pre-signed S3 URL for downloading cluster files.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_get_presigned_for_cluster_files_with_http_info(cluster_id, file_name, logs_type, host_id, additional_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster that owns the file that should be downloaded. (required)
        :type cluster_id: str
        :param file_name: The file to be downloaded. (required)
        :type file_name: str
        :param logs_type: If downloading logs, the type of logs to download.
        :type logs_type: str
        :param host_id: If downloading a file related to a host, the relevant host.
        :type host_id: str
        :param additional_name: If downloading a manifest, the file name, prefaced with folder name, for example, openshift/99-openshift-xyz.yaml.
        :type additional_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PresignedUrl, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'file_name',
            'logs_type',
            'host_id',
            'additional_name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_get_presigned_for_cluster_files" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        if _params.get('file_name') is not None:  # noqa: E501
            _query_params.append(('file_name', _params['file_name']))

        if _params.get('logs_type') is not None:  # noqa: E501
            _query_params.append(('logs_type', _params['logs_type']))

        if _params.get('host_id') is not None:  # noqa: E501
            _query_params.append(('host_id', _params['host_id']))

        if _params.get('additional_name') is not None:  # noqa: E501
            _query_params.append(('additional_name', _params['additional_name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "PresignedUrl",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/downloads/files-presigned', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_import_cluster(self, new_import_cluster_params : Annotated[ImportClusterParams, Field(..., description="Parameters for importing a OCP cluster for adding nodes.")], **kwargs) -> Cluster:  # noqa: E501
        """v2_import_cluster  # noqa: E501

        Import an AI cluster using minimal data associated with existing OCP cluster, in order to allow adding day2 hosts to that cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_import_cluster(new_import_cluster_params, async_req=True)
        >>> result = thread.get()

        :param new_import_cluster_params: Parameters for importing a OCP cluster for adding nodes. (required)
        :type new_import_cluster_params: ImportClusterParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cluster
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_import_cluster_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_import_cluster_with_http_info(new_import_cluster_params, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_import_cluster_with_http_info(self, new_import_cluster_params : Annotated[ImportClusterParams, Field(..., description="Parameters for importing a OCP cluster for adding nodes.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_import_cluster  # noqa: E501

        Import an AI cluster using minimal data associated with existing OCP cluster, in order to allow adding day2 hosts to that cluster  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_import_cluster_with_http_info(new_import_cluster_params, async_req=True)
        >>> result = thread.get()

        :param new_import_cluster_params: Parameters for importing a OCP cluster for adding nodes. (required)
        :type new_import_cluster_params: ImportClusterParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cluster, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'new_import_cluster_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_import_cluster" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['new_import_cluster_params'] is not None:
            _body_params = _params['new_import_cluster_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '201': "Cluster",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/import', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_install_cluster(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to be installed.")], **kwargs) -> Cluster:  # noqa: E501
        """v2_install_cluster  # noqa: E501

        Installs the OpenShift cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_install_cluster(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to be installed. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cluster
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_install_cluster_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_install_cluster_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_install_cluster_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to be installed.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_install_cluster  # noqa: E501

        Installs the OpenShift cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_install_cluster_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to be installed. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cluster, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_install_cluster" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '202': "Cluster",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/actions/install', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_install_host(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is being installed.")], host_id : Annotated[StrictStr, Field(..., description="The host that is being installed.")], **kwargs) -> Host:  # noqa: E501
        """v2_install_host  # noqa: E501

        install specific host for day2 cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_install_host(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is being installed. (required)
        :type infra_env_id: str
        :param host_id: The host that is being installed. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Host
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_install_host_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_install_host_with_http_info(infra_env_id, host_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_install_host_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is being installed.")], host_id : Annotated[StrictStr, Field(..., description="The host that is being installed.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_install_host  # noqa: E501

        install specific host for day2 cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_install_host_with_http_info(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is being installed. (required)
        :type infra_env_id: str
        :param host_id: The host that is being installed. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Host, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_install_host" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '202': "Host",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/install', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_list_clusters(self, get_unregistered_clusters : Annotated[Optional[StrictBool], Field(description="Whether to return clusters that have been unregistered.")] = None, openshift_cluster_id : Annotated[Optional[StrictStr], Field(description="A specific cluster to retrieve.")] = None, ams_subscription_ids : Annotated[Optional[conlist(StrictStr)], Field(description="If non-empty, returned Clusters are filtered to those with matching subscription IDs.")] = None, with_hosts : Annotated[Optional[StrictBool], Field(description="Include hosts in the returned list.")] = None, owner : Annotated[Optional[StrictStr], Field(description="If provided, returns only clusters that are owned by the specified user.")] = None, **kwargs) -> List[Cluster]:  # noqa: E501
        """v2_list_clusters  # noqa: E501

        Retrieves the list of OpenShift clusters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_list_clusters(get_unregistered_clusters, openshift_cluster_id, ams_subscription_ids, with_hosts, owner, async_req=True)
        >>> result = thread.get()

        :param get_unregistered_clusters: Whether to return clusters that have been unregistered.
        :type get_unregistered_clusters: bool
        :param openshift_cluster_id: A specific cluster to retrieve.
        :type openshift_cluster_id: str
        :param ams_subscription_ids: If non-empty, returned Clusters are filtered to those with matching subscription IDs.
        :type ams_subscription_ids: List[str]
        :param with_hosts: Include hosts in the returned list.
        :type with_hosts: bool
        :param owner: If provided, returns only clusters that are owned by the specified user.
        :type owner: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Cluster]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_list_clusters_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_list_clusters_with_http_info(get_unregistered_clusters, openshift_cluster_id, ams_subscription_ids, with_hosts, owner, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_list_clusters_with_http_info(self, get_unregistered_clusters : Annotated[Optional[StrictBool], Field(description="Whether to return clusters that have been unregistered.")] = None, openshift_cluster_id : Annotated[Optional[StrictStr], Field(description="A specific cluster to retrieve.")] = None, ams_subscription_ids : Annotated[Optional[conlist(StrictStr)], Field(description="If non-empty, returned Clusters are filtered to those with matching subscription IDs.")] = None, with_hosts : Annotated[Optional[StrictBool], Field(description="Include hosts in the returned list.")] = None, owner : Annotated[Optional[StrictStr], Field(description="If provided, returns only clusters that are owned by the specified user.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_list_clusters  # noqa: E501

        Retrieves the list of OpenShift clusters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_list_clusters_with_http_info(get_unregistered_clusters, openshift_cluster_id, ams_subscription_ids, with_hosts, owner, async_req=True)
        >>> result = thread.get()

        :param get_unregistered_clusters: Whether to return clusters that have been unregistered.
        :type get_unregistered_clusters: bool
        :param openshift_cluster_id: A specific cluster to retrieve.
        :type openshift_cluster_id: str
        :param ams_subscription_ids: If non-empty, returned Clusters are filtered to those with matching subscription IDs.
        :type ams_subscription_ids: List[str]
        :param with_hosts: Include hosts in the returned list.
        :type with_hosts: bool
        :param owner: If provided, returns only clusters that are owned by the specified user.
        :type owner: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Cluster], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'get_unregistered_clusters',
            'openshift_cluster_id',
            'ams_subscription_ids',
            'with_hosts',
            'owner'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_list_clusters" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('openshift_cluster_id') is not None:  # noqa: E501
            _query_params.append(('openshift_cluster_id', _params['openshift_cluster_id']))

        if _params.get('ams_subscription_ids') is not None:  # noqa: E501
            _query_params.append(('ams_subscription_ids', _params['ams_subscription_ids']))
            _collection_formats['ams_subscription_ids'] = 'csv'

        if _params.get('with_hosts') is not None:  # noqa: E501
            _query_params.append(('with_hosts', _params['with_hosts']))

        if _params.get('owner') is not None:  # noqa: E501
            _query_params.append(('owner', _params['owner']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['get_unregistered_clusters']:
            _header_params['get_unregistered_clusters'] = _params['get_unregistered_clusters']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "List[Cluster]",
            '401': "InfraError",
            '403': "InfraError",
            '405': "Error",
            '500': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_list_feature_support_levels(self, **kwargs) -> List[FeatureSupportLevel]:  # noqa: E501
        """(Deprecated) v2_list_feature_support_levels  # noqa: E501

        (DEPRECATED) Retrieves the support levels for features for each OpenShift version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_list_feature_support_levels(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[FeatureSupportLevel]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_list_feature_support_levels_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_list_feature_support_levels_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def v2_list_feature_support_levels_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """(Deprecated) v2_list_feature_support_levels  # noqa: E501

        (DEPRECATED) Retrieves the support levels for features for each OpenShift version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_list_feature_support_levels_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[FeatureSupportLevel], status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn("GET /v2/feature-support-levels is deprecated.", DeprecationWarning)

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_list_feature_support_levels" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "List[FeatureSupportLevel]",
            '401': "InfraError",
            '403': "InfraError",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/feature-support-levels', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_list_hosts(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env that the hosts are asociated with.")], **kwargs) -> List[Host]:  # noqa: E501
        """v2_list_hosts  # noqa: E501

        Retrieves the list of OpenShift hosts that belong the infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_list_hosts(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env that the hosts are asociated with. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Host]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_list_hosts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_list_hosts_with_http_info(infra_env_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_list_hosts_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env that the hosts are asociated with.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_list_hosts  # noqa: E501

        Retrieves the list of OpenShift hosts that belong the infra-env.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_list_hosts_with_http_info(infra_env_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env that the hosts are asociated with. (required)
        :type infra_env_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Host], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_list_hosts" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth', 'agentAuth']  # noqa: E501

        _response_types_map = {
            '200': "List[Host]",
            '401': "InfraError",
            '403': "InfraError",
            '405': "Error",
            '500': "Error",
            '501': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_list_of_cluster_operators(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to return operators for.")], operator_name : Annotated[Optional[StrictStr], Field(description="An operator in the specified cluster to return its data.")] = None, **kwargs) -> List[MonitoredOperator]:  # noqa: E501
        """v2_list_of_cluster_operators  # noqa: E501

        Lists operators to be monitored for a cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_list_of_cluster_operators(cluster_id, operator_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to return operators for. (required)
        :type cluster_id: str
        :param operator_name: An operator in the specified cluster to return its data.
        :type operator_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[MonitoredOperator]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_list_of_cluster_operators_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_list_of_cluster_operators_with_http_info(cluster_id, operator_name, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_list_of_cluster_operators_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to return operators for.")], operator_name : Annotated[Optional[StrictStr], Field(description="An operator in the specified cluster to return its data.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_list_of_cluster_operators  # noqa: E501

        Lists operators to be monitored for a cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_list_of_cluster_operators_with_http_info(cluster_id, operator_name, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to return operators for. (required)
        :type cluster_id: str
        :param operator_name: An operator in the specified cluster to return its data.
        :type operator_name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[MonitoredOperator], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'operator_name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_list_of_cluster_operators" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        if _params.get('operator_name') is not None:  # noqa: E501
            _query_params.append(('operator_name', _params['operator_name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['agentAuth']  # noqa: E501

        _response_types_map = {
            '200': "List[MonitoredOperator]",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/monitored-operators', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_post_step_reply(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is posting results.")], host_id : Annotated[StrictStr, Field(..., description="The host that is posting results.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is posting results.")] = None, reply : Annotated[Optional[StepReply], Field(description="The results to be posted.")] = None, **kwargs) -> None:  # noqa: E501
        """v2_post_step_reply  # noqa: E501

        Posts the result of the operations from the host agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_post_step_reply(infra_env_id, host_id, discovery_agent_version, reply, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is posting results. (required)
        :type infra_env_id: str
        :param host_id: The host that is posting results. (required)
        :type host_id: str
        :param discovery_agent_version: The software version of the discovery agent that is posting results.
        :type discovery_agent_version: str
        :param reply: The results to be posted.
        :type reply: StepReply
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_post_step_reply_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_post_step_reply_with_http_info(infra_env_id, host_id, discovery_agent_version, reply, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_post_step_reply_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is posting results.")], host_id : Annotated[StrictStr, Field(..., description="The host that is posting results.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is posting results.")] = None, reply : Annotated[Optional[StepReply], Field(description="The results to be posted.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_post_step_reply  # noqa: E501

        Posts the result of the operations from the host agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_post_step_reply_with_http_info(infra_env_id, host_id, discovery_agent_version, reply, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is posting results. (required)
        :type infra_env_id: str
        :param host_id: The host that is posting results. (required)
        :type host_id: str
        :param discovery_agent_version: The software version of the discovery agent that is posting results.
        :type discovery_agent_version: str
        :param reply: The results to be posted.
        :type reply: StepReply
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id',
            'discovery_agent_version',
            'reply'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_post_step_reply" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['discovery_agent_version']:
            _header_params['discovery_agent_version'] = _params['discovery_agent_version']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['reply'] is not None:
            _body_params = _params['reply']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['agentAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/instructions', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_register_cluster(self, new_cluster_params : Annotated[ClusterCreateParams, Field(..., description="The properties describing the new cluster.")], **kwargs) -> Cluster:  # noqa: E501
        """v2_register_cluster  # noqa: E501

        Creates a new OpenShift cluster definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_register_cluster(new_cluster_params, async_req=True)
        >>> result = thread.get()

        :param new_cluster_params: The properties describing the new cluster. (required)
        :type new_cluster_params: ClusterCreateParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cluster
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_register_cluster_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_register_cluster_with_http_info(new_cluster_params, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_register_cluster_with_http_info(self, new_cluster_params : Annotated[ClusterCreateParams, Field(..., description="The properties describing the new cluster.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_register_cluster  # noqa: E501

        Creates a new OpenShift cluster definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_register_cluster_with_http_info(new_cluster_params, async_req=True)
        >>> result = thread.get()

        :param new_cluster_params: The properties describing the new cluster. (required)
        :type new_cluster_params: ClusterCreateParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cluster, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'new_cluster_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_register_cluster" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['new_cluster_params'] is not None:
            _body_params = _params['new_cluster_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '201': "Cluster",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '405': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_register_host(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env that the agent is associated with.")], new_host_params : Annotated[HostCreateParams, Field(..., description="The description of the agent being registered.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is registering the agent.")] = None, **kwargs) -> HostRegistrationResponse:  # noqa: E501
        """v2_register_host  # noqa: E501

        Registers a new OpenShift agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_register_host(infra_env_id, new_host_params, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env that the agent is associated with. (required)
        :type infra_env_id: str
        :param new_host_params: The description of the agent being registered. (required)
        :type new_host_params: HostCreateParams
        :param discovery_agent_version: The software version of the discovery agent that is registering the agent.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: HostRegistrationResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_register_host_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_register_host_with_http_info(infra_env_id, new_host_params, discovery_agent_version, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_register_host_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env that the agent is associated with.")], new_host_params : Annotated[HostCreateParams, Field(..., description="The description of the agent being registered.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is registering the agent.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_register_host  # noqa: E501

        Registers a new OpenShift agent.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_register_host_with_http_info(infra_env_id, new_host_params, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env that the agent is associated with. (required)
        :type infra_env_id: str
        :param new_host_params: The description of the agent being registered. (required)
        :type new_host_params: HostCreateParams
        :param discovery_agent_version: The software version of the discovery agent that is registering the agent.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(HostRegistrationResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'new_host_params',
            'discovery_agent_version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_register_host" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['discovery_agent_version']:
            _header_params['discovery_agent_version'] = _params['discovery_agent_version']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['new_host_params'] is not None:
            _body_params = _params['new_host_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['agentAuth']  # noqa: E501

        _response_types_map = {
            '201': "HostRegistrationResponse",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
            '501': "Error",
            '503': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_report_monitored_operator_status(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose operators are being monitored.")], report_params : Annotated[OperatorMonitorReport, Field(..., description="The operators monitor report.")], **kwargs) -> None:  # noqa: E501
        """v2_report_monitored_operator_status  # noqa: E501

        Controller API to report of monitored operators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_report_monitored_operator_status(cluster_id, report_params, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose operators are being monitored. (required)
        :type cluster_id: str
        :param report_params: The operators monitor report. (required)
        :type report_params: OperatorMonitorReport
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_report_monitored_operator_status_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_report_monitored_operator_status_with_http_info(cluster_id, report_params, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_report_monitored_operator_status_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose operators are being monitored.")], report_params : Annotated[OperatorMonitorReport, Field(..., description="The operators monitor report.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_report_monitored_operator_status  # noqa: E501

        Controller API to report of monitored operators.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_report_monitored_operator_status_with_http_info(cluster_id, report_params, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose operators are being monitored. (required)
        :type cluster_id: str
        :param report_params: The operators monitor report. (required)
        :type report_params: OperatorMonitorReport
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'report_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_report_monitored_operator_status" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['report_params'] is not None:
            _body_params = _params['report_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['agentAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/monitored-operators', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_reset_cluster(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose installation is to be reset.")], **kwargs) -> Cluster:  # noqa: E501
        """v2_reset_cluster  # noqa: E501

        Resets a failed installation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_reset_cluster(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose installation is to be reset. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cluster
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_reset_cluster_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_reset_cluster_with_http_info(cluster_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_reset_cluster_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose installation is to be reset.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_reset_cluster  # noqa: E501

        Resets a failed installation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_reset_cluster_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose installation is to be reset. (required)
        :type cluster_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cluster, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_reset_cluster" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '202': "Cluster",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/actions/reset', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_reset_host(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is being reset.")], host_id : Annotated[StrictStr, Field(..., description="The host that is being reset.")], **kwargs) -> Host:  # noqa: E501
        """v2_reset_host  # noqa: E501

        reset a failed host for day2 cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_reset_host(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is being reset. (required)
        :type infra_env_id: str
        :param host_id: The host that is being reset. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Host
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_reset_host_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_reset_host_with_http_info(infra_env_id, host_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_reset_host_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that is being reset.")], host_id : Annotated[StrictStr, Field(..., description="The host that is being reset.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_reset_host  # noqa: E501

        reset a failed host for day2 cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_reset_host_with_http_info(infra_env_id, host_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that is being reset. (required)
        :type infra_env_id: str
        :param host_id: The host that is being reset. (required)
        :type host_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Host, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_reset_host" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "Host",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/reset', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_reset_host_validation(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that its validation is being reset.")], host_id : Annotated[StrictStr, Field(..., description="The host that its validation is being reset.")], validation_id : Annotated[StrictStr, Field(..., description="The id of the validation being reset.")], **kwargs) -> Host:  # noqa: E501
        """Reset failed host validation.  # noqa: E501

        Reset failed host validation. It may be performed on any host validation with persistent validation result.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_reset_host_validation(infra_env_id, host_id, validation_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that its validation is being reset. (required)
        :type infra_env_id: str
        :param host_id: The host that its validation is being reset. (required)
        :type host_id: str
        :param validation_id: The id of the validation being reset. (required)
        :type validation_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Host
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_reset_host_validation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_reset_host_validation_with_http_info(infra_env_id, host_id, validation_id, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_reset_host_validation_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host that its validation is being reset.")], host_id : Annotated[StrictStr, Field(..., description="The host that its validation is being reset.")], validation_id : Annotated[StrictStr, Field(..., description="The id of the validation being reset.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Reset failed host validation.  # noqa: E501

        Reset failed host validation. It may be performed on any host validation with persistent validation result.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_reset_host_validation_with_http_info(infra_env_id, host_id, validation_id, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host that its validation is being reset. (required)
        :type infra_env_id: str
        :param host_id: The host that its validation is being reset. (required)
        :type host_id: str
        :param validation_id: The id of the validation being reset. (required)
        :type validation_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Host, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id',
            'validation_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_reset_host_validation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']

        if _params['validation_id']:
            _path_params['validation_id'] = _params['validation_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "Host",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/reset-validation/{validation_id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_set_ignored_validations(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose failing validations should be ignored according to this list.")], ignored_validations : Annotated[IgnoredValidations, Field(..., description="The validations to be ignored.")], **kwargs) -> IgnoredValidations:  # noqa: E501
        """v2_set_ignored_validations  # noqa: E501

        Register the validations which are to be ignored for this cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_set_ignored_validations(cluster_id, ignored_validations, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose failing validations should be ignored according to this list. (required)
        :type cluster_id: str
        :param ignored_validations: The validations to be ignored. (required)
        :type ignored_validations: IgnoredValidations
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: IgnoredValidations
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_set_ignored_validations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_set_ignored_validations_with_http_info(cluster_id, ignored_validations, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_set_ignored_validations_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose failing validations should be ignored according to this list.")], ignored_validations : Annotated[IgnoredValidations, Field(..., description="The validations to be ignored.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_set_ignored_validations  # noqa: E501

        Register the validations which are to be ignored for this cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_set_ignored_validations_with_http_info(cluster_id, ignored_validations, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose failing validations should be ignored according to this list. (required)
        :type cluster_id: str
        :param ignored_validations: The validations to be ignored. (required)
        :type ignored_validations: IgnoredValidations
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(IgnoredValidations, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'ignored_validations'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_set_ignored_validations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['ignored_validations'] is not None:
            _body_params = _params['ignored_validations']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '201': "IgnoredValidations",
            '400': "Error",
            '404': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/ignored-validations', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_update_cluster(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to be updated.")], cluster_update_params : Annotated[V2ClusterUpdateParams, Field(..., description="The properties to update.")], **kwargs) -> Cluster:  # noqa: E501
        """v2_update_cluster  # noqa: E501

        Updates an OpenShift cluster definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_cluster(cluster_id, cluster_update_params, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to be updated. (required)
        :type cluster_id: str
        :param cluster_update_params: The properties to update. (required)
        :type cluster_update_params: V2ClusterUpdateParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Cluster
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_update_cluster_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_update_cluster_with_http_info(cluster_id, cluster_update_params, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_update_cluster_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to be updated.")], cluster_update_params : Annotated[V2ClusterUpdateParams, Field(..., description="The properties to update.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_update_cluster  # noqa: E501

        Updates an OpenShift cluster definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_cluster_with_http_info(cluster_id, cluster_update_params, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to be updated. (required)
        :type cluster_id: str
        :param cluster_update_params: The properties to update. (required)
        :type cluster_update_params: V2ClusterUpdateParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Cluster, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'cluster_update_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_update_cluster" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['cluster_update_params'] is not None:
            _body_params = _params['cluster_update_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '201': "Cluster",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_update_cluster_install_config(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose install config is being updated.")], install_config_params : Annotated[StrictStr, Field(..., description="Install config overrides.")], **kwargs) -> None:  # noqa: E501
        """v2_update_cluster_install_config  # noqa: E501

        Override values in the install config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_cluster_install_config(cluster_id, install_config_params, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose install config is being updated. (required)
        :type cluster_id: str
        :param install_config_params: Install config overrides. (required)
        :type install_config_params: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_update_cluster_install_config_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_update_cluster_install_config_with_http_info(cluster_id, install_config_params, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_update_cluster_install_config_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose install config is being updated.")], install_config_params : Annotated[StrictStr, Field(..., description="Install config overrides.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_update_cluster_install_config  # noqa: E501

        Override values in the install config.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_cluster_install_config_with_http_info(cluster_id, install_config_params, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose install config is being updated. (required)
        :type cluster_id: str
        :param install_config_params: Install config overrides. (required)
        :type install_config_params: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'install_config_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_update_cluster_install_config" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['install_config_params'] is not None:
            _body_params = _params['install_config_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/install-config', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_update_cluster_logs_progress(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose log progress is being updated.")], logs_progress_params : Annotated[LogsProgressParams, Field(..., description="Parameters for updating log progress.")], **kwargs) -> None:  # noqa: E501
        """v2_update_cluster_logs_progress  # noqa: E501

        Update log collection state and progress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_cluster_logs_progress(cluster_id, logs_progress_params, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose log progress is being updated. (required)
        :type cluster_id: str
        :param logs_progress_params: Parameters for updating log progress. (required)
        :type logs_progress_params: LogsProgressParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_update_cluster_logs_progress_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_update_cluster_logs_progress_with_http_info(cluster_id, logs_progress_params, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_update_cluster_logs_progress_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose log progress is being updated.")], logs_progress_params : Annotated[LogsProgressParams, Field(..., description="Parameters for updating log progress.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_update_cluster_logs_progress  # noqa: E501

        Update log collection state and progress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_cluster_logs_progress_with_http_info(cluster_id, logs_progress_params, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose log progress is being updated. (required)
        :type cluster_id: str
        :param logs_progress_params: Parameters for updating log progress. (required)
        :type logs_progress_params: LogsProgressParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'logs_progress_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_update_cluster_logs_progress" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['logs_progress_params'] is not None:
            _body_params = _params['logs_progress_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['agentAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/logs-progress', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_update_cluster_ui_settings(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster for which UI settings should be updated.")], ui_settings : Annotated[StrictStr, Field(..., description="Settings for the installer UI.")], **kwargs) -> str:  # noqa: E501
        """v2_update_cluster_ui_settings  # noqa: E501

        Update cluster specific UI settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_cluster_ui_settings(cluster_id, ui_settings, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster for which UI settings should be updated. (required)
        :type cluster_id: str
        :param ui_settings: Settings for the installer UI. (required)
        :type ui_settings: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_update_cluster_ui_settings_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_update_cluster_ui_settings_with_http_info(cluster_id, ui_settings, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_update_cluster_ui_settings_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster for which UI settings should be updated.")], ui_settings : Annotated[StrictStr, Field(..., description="Settings for the installer UI.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_update_cluster_ui_settings  # noqa: E501

        Update cluster specific UI settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_cluster_ui_settings_with_http_info(cluster_id, ui_settings, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster for which UI settings should be updated. (required)
        :type cluster_id: str
        :param ui_settings: Settings for the installer UI. (required)
        :type ui_settings: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'ui_settings'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_update_cluster_ui_settings" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['ui_settings'] is not None:
            _body_params = _params['ui_settings']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "Error",
            '404': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/ui-settings', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_update_host(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env ID of the host to be updated.")], host_id : Annotated[StrictStr, Field(..., description="The host that should be updated.")], host_update_params : Annotated[HostUpdateParams, Field(..., description="The properties to update.")], **kwargs) -> Host:  # noqa: E501
        """v2_update_host  # noqa: E501

        Update an Openshift host  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_host(infra_env_id, host_id, host_update_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env ID of the host to be updated. (required)
        :type infra_env_id: str
        :param host_id: The host that should be updated. (required)
        :type host_id: str
        :param host_update_params: The properties to update. (required)
        :type host_update_params: HostUpdateParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Host
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_update_host_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_update_host_with_http_info(infra_env_id, host_id, host_update_params, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_update_host_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env ID of the host to be updated.")], host_id : Annotated[StrictStr, Field(..., description="The host that should be updated.")], host_update_params : Annotated[HostUpdateParams, Field(..., description="The properties to update.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_update_host  # noqa: E501

        Update an Openshift host  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_host_with_http_info(infra_env_id, host_id, host_update_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env ID of the host to be updated. (required)
        :type infra_env_id: str
        :param host_id: The host that should be updated. (required)
        :type host_id: str
        :param host_update_params: The properties to update. (required)
        :type host_update_params: HostUpdateParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Host, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id',
            'host_update_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_update_host" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['host_update_params'] is not None:
            _body_params = _params['host_update_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '201': "Host",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_update_host_ignition(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host whose ignition file should be updated.")], host_id : Annotated[StrictStr, Field(..., description="The host whose ignition file should be updated.")], host_ignition_params : Annotated[HostIgnitionParams, Field(..., description="Ignition config overrides.")], **kwargs) -> None:  # noqa: E501
        """v2_update_host_ignition  # noqa: E501

        Patch the ignition file for this host  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_host_ignition(infra_env_id, host_id, host_ignition_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host whose ignition file should be updated. (required)
        :type infra_env_id: str
        :param host_id: The host whose ignition file should be updated. (required)
        :type host_id: str
        :param host_ignition_params: Ignition config overrides. (required)
        :type host_ignition_params: HostIgnitionParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_update_host_ignition_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_update_host_ignition_with_http_info(infra_env_id, host_id, host_ignition_params, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_update_host_ignition_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host whose ignition file should be updated.")], host_id : Annotated[StrictStr, Field(..., description="The host whose ignition file should be updated.")], host_ignition_params : Annotated[HostIgnitionParams, Field(..., description="Ignition config overrides.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_update_host_ignition  # noqa: E501

        Patch the ignition file for this host  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_host_ignition_with_http_info(infra_env_id, host_id, host_ignition_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host whose ignition file should be updated. (required)
        :type infra_env_id: str
        :param host_id: The host whose ignition file should be updated. (required)
        :type host_id: str
        :param host_ignition_params: Ignition config overrides. (required)
        :type host_ignition_params: HostIgnitionParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id',
            'host_ignition_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_update_host_ignition" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['host_ignition_params'] is not None:
            _body_params = _params['host_ignition_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/ignition', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_update_host_install_progress(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host being updated.")], host_id : Annotated[StrictStr, Field(..., description="The ID of the host to update.")], host_progress : Annotated[HostProgress, Field(..., description="New progress value.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is updating progress.")] = None, **kwargs) -> None:  # noqa: E501
        """v2_update_host_install_progress  # noqa: E501

        Update installation progress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_host_install_progress(infra_env_id, host_id, host_progress, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host being updated. (required)
        :type infra_env_id: str
        :param host_id: The ID of the host to update. (required)
        :type host_id: str
        :param host_progress: New progress value. (required)
        :type host_progress: HostProgress
        :param discovery_agent_version: The software version of the discovery agent that is updating progress.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_update_host_install_progress_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_update_host_install_progress_with_http_info(infra_env_id, host_id, host_progress, discovery_agent_version, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_update_host_install_progress_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host being updated.")], host_id : Annotated[StrictStr, Field(..., description="The ID of the host to update.")], host_progress : Annotated[HostProgress, Field(..., description="New progress value.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is updating progress.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_update_host_install_progress  # noqa: E501

        Update installation progress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_host_install_progress_with_http_info(infra_env_id, host_id, host_progress, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host being updated. (required)
        :type infra_env_id: str
        :param host_id: The ID of the host to update. (required)
        :type host_id: str
        :param host_progress: New progress value. (required)
        :type host_progress: HostProgress
        :param discovery_agent_version: The software version of the discovery agent that is updating progress.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id',
            'host_progress',
            'discovery_agent_version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_update_host_install_progress" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['discovery_agent_version']:
            _header_params['discovery_agent_version'] = _params['discovery_agent_version']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['host_progress'] is not None:
            _body_params = _params['host_progress']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['agentAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/progress', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_update_host_installer_args(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host whose installer arguments should be updated.")], host_id : Annotated[StrictStr, Field(..., description="The host whose installer arguments should be updated.")], installer_args_params : Annotated[InstallerArgsParams, Field(..., description="The updated installer arguments.")], **kwargs) -> Host:  # noqa: E501
        """v2_update_host_installer_args  # noqa: E501

        Updates a host's installer arguments.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_host_installer_args(infra_env_id, host_id, installer_args_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host whose installer arguments should be updated. (required)
        :type infra_env_id: str
        :param host_id: The host whose installer arguments should be updated. (required)
        :type host_id: str
        :param installer_args_params: The updated installer arguments. (required)
        :type installer_args_params: InstallerArgsParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Host
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_update_host_installer_args_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_update_host_installer_args_with_http_info(infra_env_id, host_id, installer_args_params, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_update_host_installer_args_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env of the host whose installer arguments should be updated.")], host_id : Annotated[StrictStr, Field(..., description="The host whose installer arguments should be updated.")], installer_args_params : Annotated[InstallerArgsParams, Field(..., description="The updated installer arguments.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_update_host_installer_args  # noqa: E501

        Updates a host's installer arguments.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_host_installer_args_with_http_info(infra_env_id, host_id, installer_args_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env of the host whose installer arguments should be updated. (required)
        :type infra_env_id: str
        :param host_id: The host whose installer arguments should be updated. (required)
        :type host_id: str
        :param installer_args_params: The updated installer arguments. (required)
        :type installer_args_params: InstallerArgsParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Host, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id',
            'installer_args_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_update_host_installer_args" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['installer_args_params'] is not None:
            _body_params = _params['installer_args_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['userAuth']  # noqa: E501

        _response_types_map = {
            '201': "Host",
            '400': "Error",
            '401': "InfraError",
            '403': "InfraError",
            '404': "Error",
            '405': "Error",
            '409': "Error",
            '500': "Error",
            '501': "Error",
        }

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/installer-args', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_update_host_logs_progress(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env whose log progress is being updated.")], host_id : Annotated[StrictStr, Field(..., description="The host whose log progress is being updated.")], logs_progress_params : Annotated[LogsProgressParams, Field(..., description="Parameters for updating log progress.")], **kwargs) -> None:  # noqa: E501
        """v2_update_host_logs_progress  # noqa: E501

        Update log collection state and progress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_host_logs_progress(infra_env_id, host_id, logs_progress_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env whose log progress is being updated. (required)
        :type infra_env_id: str
        :param host_id: The host whose log progress is being updated. (required)
        :type host_id: str
        :param logs_progress_params: Parameters for updating log progress. (required)
        :type logs_progress_params: LogsProgressParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_update_host_logs_progress_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_update_host_logs_progress_with_http_info(infra_env_id, host_id, logs_progress_params, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_update_host_logs_progress_with_http_info(self, infra_env_id : Annotated[StrictStr, Field(..., description="The infra-env whose log progress is being updated.")], host_id : Annotated[StrictStr, Field(..., description="The host whose log progress is being updated.")], logs_progress_params : Annotated[LogsProgressParams, Field(..., description="Parameters for updating log progress.")], **kwargs) -> ApiResponse:  # noqa: E501
        """v2_update_host_logs_progress  # noqa: E501

        Update log collection state and progress.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_update_host_logs_progress_with_http_info(infra_env_id, host_id, logs_progress_params, async_req=True)
        >>> result = thread.get()

        :param infra_env_id: The infra-env whose log progress is being updated. (required)
        :type infra_env_id: str
        :param host_id: The host whose log progress is being updated. (required)
        :type host_id: str
        :param logs_progress_params: Parameters for updating log progress. (required)
        :type logs_progress_params: LogsProgressParams
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'infra_env_id',
            'host_id',
            'logs_progress_params'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_update_host_logs_progress" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['infra_env_id']:
            _path_params['infra_env_id'] = _params['infra_env_id']

        if _params['host_id']:
            _path_params['host_id'] = _params['host_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['logs_progress_params'] is not None:
            _body_params = _params['logs_progress_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['agentAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/infra-envs/{infra_env_id}/hosts/{host_id}/logs-progress', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_upload_cluster_ingress_cert(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to associate with the ingress certificate.")], ingress_cert_params : Annotated[StrictStr, Field(..., description="The ingress certificate.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is uploading the ingress certificate.")] = None, **kwargs) -> None:  # noqa: E501
        """v2_upload_cluster_ingress_cert  # noqa: E501

        Transfer the ingress certificate for the cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_upload_cluster_ingress_cert(cluster_id, ingress_cert_params, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to associate with the ingress certificate. (required)
        :type cluster_id: str
        :param ingress_cert_params: The ingress certificate. (required)
        :type ingress_cert_params: str
        :param discovery_agent_version: The software version of the discovery agent that is uploading the ingress certificate.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_upload_cluster_ingress_cert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_upload_cluster_ingress_cert_with_http_info(cluster_id, ingress_cert_params, discovery_agent_version, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_upload_cluster_ingress_cert_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster to associate with the ingress certificate.")], ingress_cert_params : Annotated[StrictStr, Field(..., description="The ingress certificate.")], discovery_agent_version : Annotated[Optional[StrictStr], Field(description="The software version of the discovery agent that is uploading the ingress certificate.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_upload_cluster_ingress_cert  # noqa: E501

        Transfer the ingress certificate for the cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_upload_cluster_ingress_cert_with_http_info(cluster_id, ingress_cert_params, discovery_agent_version, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster to associate with the ingress certificate. (required)
        :type cluster_id: str
        :param ingress_cert_params: The ingress certificate. (required)
        :type ingress_cert_params: str
        :param discovery_agent_version: The software version of the discovery agent that is uploading the ingress certificate.
        :type discovery_agent_version: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'ingress_cert_params',
            'discovery_agent_version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_upload_cluster_ingress_cert" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['discovery_agent_version']:
            _header_params['discovery_agent_version'] = _params['discovery_agent_version']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['ingress_cert_params'] is not None:
            _body_params = _params['ingress_cert_params']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['agentAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/uploads/ingress-cert', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def v2_upload_logs(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose logs should be uploaded.")], logs_type : Annotated[StrictStr, Field(..., description="The type of log file to be uploaded.")], infra_env_id : Annotated[Optional[StrictStr], Field(description="The infra-env ID of the host.")] = None, host_id : Annotated[Optional[StrictStr], Field(description="The host whose logs should be uploaded.")] = None, upfile : Annotated[Optional[Union[conbytes(strict=True, max_length=104857600), constr(strict=True, max_length=104857600)]], Field(description="The log file to be uploaded.")] = None, **kwargs) -> None:  # noqa: E501
        """v2_upload_logs  # noqa: E501

        Agent API to upload logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_upload_logs(cluster_id, logs_type, infra_env_id, host_id, upfile, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose logs should be uploaded. (required)
        :type cluster_id: str
        :param logs_type: The type of log file to be uploaded. (required)
        :type logs_type: str
        :param infra_env_id: The infra-env ID of the host.
        :type infra_env_id: str
        :param host_id: The host whose logs should be uploaded.
        :type host_id: str
        :param upfile: The log file to be uploaded.
        :type upfile: bytearray
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the v2_upload_logs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.v2_upload_logs_with_http_info(cluster_id, logs_type, infra_env_id, host_id, upfile, **kwargs)  # noqa: E501

    @validate_arguments
    def v2_upload_logs_with_http_info(self, cluster_id : Annotated[StrictStr, Field(..., description="The cluster whose logs should be uploaded.")], logs_type : Annotated[StrictStr, Field(..., description="The type of log file to be uploaded.")], infra_env_id : Annotated[Optional[StrictStr], Field(description="The infra-env ID of the host.")] = None, host_id : Annotated[Optional[StrictStr], Field(description="The host whose logs should be uploaded.")] = None, upfile : Annotated[Optional[Union[conbytes(strict=True, max_length=104857600), constr(strict=True, max_length=104857600)]], Field(description="The log file to be uploaded.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """v2_upload_logs  # noqa: E501

        Agent API to upload logs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.v2_upload_logs_with_http_info(cluster_id, logs_type, infra_env_id, host_id, upfile, async_req=True)
        >>> result = thread.get()

        :param cluster_id: The cluster whose logs should be uploaded. (required)
        :type cluster_id: str
        :param logs_type: The type of log file to be uploaded. (required)
        :type logs_type: str
        :param infra_env_id: The infra-env ID of the host.
        :type infra_env_id: str
        :param host_id: The host whose logs should be uploaded.
        :type host_id: str
        :param upfile: The log file to be uploaded.
        :type upfile: bytearray
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'cluster_id',
            'logs_type',
            'infra_env_id',
            'host_id',
            'upfile'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method v2_upload_logs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['cluster_id']:
            _path_params['cluster_id'] = _params['cluster_id']


        # process the query parameters
        _query_params = []
        if _params.get('logs_type') is not None:  # noqa: E501
            _query_params.append(('logs_type', _params['logs_type']))

        if _params.get('infra_env_id') is not None:  # noqa: E501
            _query_params.append(('infra_env_id', _params['infra_env_id']))

        if _params.get('host_id') is not None:  # noqa: E501
            _query_params.append(('host_id', _params['host_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        if _params['upfile']:
            _files['upfile'] = _params['upfile']

        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['multipart/form-data']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['agentAuth']  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/v2/clusters/{cluster_id}/logs', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
