# coding: utf-8

"""
    AssistedInstall

    Assisted installation  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint, conlist, constr, validator
from openshift_assisted_service.models.api_vip import ApiVip
from openshift_assisted_service.models.cluster_network import ClusterNetwork
from openshift_assisted_service.models.cluster_progress_info import ClusterProgressInfo
from openshift_assisted_service.models.disk_encryption import DiskEncryption
from openshift_assisted_service.models.host import Host
from openshift_assisted_service.models.host_network import HostNetwork
from openshift_assisted_service.models.ignition_endpoint import IgnitionEndpoint
from openshift_assisted_service.models.image_info import ImageInfo
from openshift_assisted_service.models.ingress_vip import IngressVip
from openshift_assisted_service.models.logs_state import LogsState
from openshift_assisted_service.models.machine_network import MachineNetwork
from openshift_assisted_service.models.monitored_operator import MonitoredOperator
from openshift_assisted_service.models.platform import Platform
from openshift_assisted_service.models.service_network import ServiceNetwork

class Cluster(BaseModel):
    """
    Cluster
    """
    kind: StrictStr = Field(..., description="Indicates the type of this object. Will be 'Cluster' if this is a complete object, 'AddHostsCluster' for cluster that add hosts to existing OCP cluster, ")
    high_availability_mode: Optional[StrictStr] = Field('Full', description="Guaranteed availability of the installed cluster. 'Full' installs a Highly-Available cluster over multiple master nodes whereas 'None' installs a full cluster over one node. ")
    id: StrictStr = Field(..., description="Unique identifier of the object.")
    href: StrictStr = Field(..., description="Self link.")
    name: Optional[StrictStr] = Field(None, description="Name of the OpenShift cluster.")
    user_name: Optional[StrictStr] = None
    org_id: Optional[StrictStr] = None
    email_domain: Optional[StrictStr] = None
    openshift_version: Optional[StrictStr] = Field(None, description="Version of the OpenShift cluster.")
    ocp_release_image: Optional[StrictStr] = Field(None, description="OpenShift release image URI.")
    openshift_cluster_id: Optional[StrictStr] = Field(None, description="Cluster ID on OCP system.")
    image_info: ImageInfo = Field(...)
    platform: Optional[Platform] = None
    base_dns_domain: Optional[StrictStr] = Field(None, description="Base domain of the cluster. All DNS records must be sub-domains of this base and include the cluster name.")
    cluster_network_cidr: Optional[constr(strict=True)] = Field(None, description="IP address block from which Pod IPs are allocated. This block must not overlap with existing physical networks. These IP addresses are used for the Pod network, and if you need to access the Pods from an external network, configure load balancers and routers to manage the traffic.")
    cluster_network_host_prefix: Optional[conint(strict=True, le=128, ge=1)] = Field(None, description="The subnet prefix length to assign to each individual node. For example, if clusterNetworkHostPrefix is set to 23, then each node is assigned a /23 subnet out of the given cidr (clusterNetworkCIDR), which allows for 510 (2^(32 - 23) - 2) pod IPs addresses. If you are required to provide access to nodes from an external network, configure load balancers and routers to manage the traffic.")
    service_network_cidr: Optional[constr(strict=True)] = Field(None, description="The IP address pool to use for service IP addresses. You can enter only one IP address pool. If you need to access the services from an external network, configure load balancers and routers to manage the traffic.")
    api_vip: Optional[constr(strict=True)] = Field(None, description="(DEPRECATED) The virtual IP used to reach the OpenShift cluster's API.")
    api_vips: Optional[conlist(ApiVip)] = Field(None, description="The virtual IPs used to reach the OpenShift cluster's API. Enter one IP address for single-stack clusters, or up to two for dual-stack clusters (at most one IP address per IP stack used). The order of stacks should be the same as order of subnets in Cluster Networks, Service Networks, and Machine Networks.")
    api_vip_dns_name: Optional[StrictStr] = Field(None, description="The domain name used to reach the OpenShift cluster API.")
    machine_network_cidr: Optional[constr(strict=True)] = Field(None, description="A CIDR that all hosts belonging to the cluster should have an interfaces with IP address that belongs to this CIDR. The api_vip belongs to this CIDR.")
    ingress_vip: Optional[constr(strict=True)] = Field(None, description="(DEPRECATED) The virtual IP used for cluster ingress traffic.")
    ingress_vips: Optional[conlist(IngressVip)] = Field(None, description="The virtual IPs used for cluster ingress traffic. Enter one IP address for single-stack clusters, or up to two for dual-stack clusters (at most one IP address per IP stack used). The order of stacks should be the same as order of subnets in Cluster Networks, Service Networks, and Machine Networks.")
    ssh_public_key: Optional[StrictStr] = Field(None, description="SSH public key for debugging OpenShift nodes.")
    http_proxy: Optional[StrictStr] = Field(None, description="A proxy URL to use for creating HTTP connections outside the cluster. http://\\<username\\>:\\<pswd\\>@\\<ip\\>:\\<port\\> ")
    https_proxy: Optional[StrictStr] = Field(None, description="A proxy URL to use for creating HTTPS connections outside the cluster. http://\\<username\\>:\\<pswd\\>@\\<ip\\>:\\<port\\> ")
    no_proxy: Optional[StrictStr] = Field(None, description="A comma-separated list of destination domain names, domains, IP addresses, or other network CIDRs to exclude from proxying.")
    status: StrictStr = Field(..., description="Status of the OpenShift cluster.")
    status_info: StrictStr = Field(..., description="Additional information pertaining to the status of the OpenShift cluster.")
    status_updated_at: Optional[datetime] = Field(None, description="The last time that the cluster status was updated.")
    progress: Optional[ClusterProgressInfo] = None
    disk_encryption: Optional[DiskEncryption] = None
    hosts: Optional[conlist(Host)] = Field(None, description="Hosts that are associated with this cluster.")
    ready_host_count: Optional[StrictInt] = Field(None, description="hosts associated to this cluster that are in 'known' state.")
    enabled_host_count: Optional[StrictInt] = Field(None, description="hosts associated to this cluster that are not in 'disabled' state.")
    total_host_count: Optional[StrictInt] = Field(None, description="All hosts associated to this cluster.")
    schedulable_masters: Optional[StrictBool] = Field(False, description="Schedule workloads on masters")
    schedulable_masters_forced_true: Optional[StrictBool] = Field(True, description="Indicates if schedule workloads on masters will be enabled regardless the value of 'schedulable_masters' property. Set to 'true' when not enough hosts are associated with this cluster to disable the scheduling on masters. ")
    updated_at: Optional[datetime] = Field(None, description="The last time that this cluster was updated.")
    created_at: Optional[datetime] = Field(None, description="The time that this cluster was created.")
    install_started_at: Optional[datetime] = Field(None, description="The time that this cluster started installation.")
    install_completed_at: Optional[datetime] = Field(None, description="The time that this cluster completed installation.")
    host_networks: Optional[conlist(HostNetwork)] = Field(None, description="List of host networks to be filled during query.")
    pull_secret_set: Optional[StrictBool] = Field(None, description="True if the pull secret has been added to the cluster.")
    vip_dhcp_allocation: Optional[StrictBool] = Field(None, description="Indicate if virtual IP DHCP allocation mode is enabled.")
    validations_info: Optional[StrictStr] = Field(None, description="JSON-formatted string containing the validation results for each validation id grouped by category (network, hosts-data, etc.)")
    logs_info: Optional[LogsState] = None
    install_config_overrides: Optional[StrictStr] = Field(None, description="JSON-formatted string containing the user overrides for the install-config.yaml file.")
    controller_logs_collected_at: Optional[datetime] = None
    controller_logs_started_at: Optional[datetime] = None
    connectivity_majority_groups: Optional[StrictStr] = Field(None, description="Json formatted string containing the majority groups for connectivity checks.")
    ip_collisions: Optional[StrictStr] = Field(None, description="Json formatted string containing ip collisions detected in the cluster.")
    ignored_host_validations: Optional[StrictStr] = Field(None, description="Json formatted string containing a list of host validations to be ignored. May also contain a list with a single string \"all\" to ignore all host validations. Some validations cannot be ignored.")
    ignored_cluster_validations: Optional[StrictStr] = Field(None, description="Json formatted string containing a list of cluster validations to be ignored. May also contain a list with a single string \"all\" to ignore all cluster validations. Some validations cannot be ignored.")
    deleted_at: Optional[Dict[str, Any]] = Field(None, description="swagger:ignore")
    user_managed_networking: Optional[StrictBool] = Field(None, description="(DEPRECATED) Indicate if the networking is managed by the user.")
    additional_ntp_source: Optional[StrictStr] = Field(None, description="A comma-separated list of NTP sources (name or IP) going to be added to all the hosts.")
    monitored_operators: Optional[conlist(MonitoredOperator)] = Field(None, description="Operators that are associated with this cluster.")
    ams_subscription_id: Optional[StrictStr] = Field(None, description="Unique identifier of the AMS subscription in OCM.")
    hyperthreading: Optional[StrictStr] = Field(None, description="Enable/disable hyperthreading on master nodes, worker nodes, or all nodes")
    feature_usage: Optional[StrictStr] = Field(None, description="JSON-formatted string containing the usage information by feature name")
    network_type: Optional[StrictStr] = Field(None, description="The desired network type used.")
    cluster_networks: Optional[conlist(ClusterNetwork)] = Field(None, description="Cluster networks that are associated with this cluster.")
    service_networks: Optional[conlist(ServiceNetwork)] = Field(None, description="Service networks that are associated with this cluster.")
    machine_networks: Optional[conlist(MachineNetwork)] = Field(None, description="Machine networks that are associated with this cluster.")
    cpu_architecture: Optional[StrictStr] = Field('x86_64', description="The CPU architecture of the image (x86_64/arm64/etc).")
    ignition_endpoint: Optional[IgnitionEndpoint] = None
    imported: Optional[StrictBool] = Field(False, description="Indicates whether this cluster is an imported day-2 cluster or a regular cluster. Clusters are considered imported when they are created via the ../clusters/import endpoint. Day-2 clusters converted from day-1 clusters by kube-api controllers or the ../clusters/<cluster_id>/actions/allow-add-hosts endpoint are not considered imported. Imported clusters usually lack a lot of information and are filled with default values that don't necessarily reflect the actual cluster they represent")
    tags: Optional[StrictStr] = Field(None, description="A comma-separated list of tags that are associated to the cluster.")
    __properties = ["kind", "high_availability_mode", "id", "href", "name", "user_name", "org_id", "email_domain", "openshift_version", "ocp_release_image", "openshift_cluster_id", "image_info", "platform", "base_dns_domain", "cluster_network_cidr", "cluster_network_host_prefix", "service_network_cidr", "api_vip", "api_vips", "api_vip_dns_name", "machine_network_cidr", "ingress_vip", "ingress_vips", "ssh_public_key", "http_proxy", "https_proxy", "no_proxy", "status", "status_info", "status_updated_at", "progress", "disk_encryption", "hosts", "ready_host_count", "enabled_host_count", "total_host_count", "schedulable_masters", "schedulable_masters_forced_true", "updated_at", "created_at", "install_started_at", "install_completed_at", "host_networks", "pull_secret_set", "vip_dhcp_allocation", "validations_info", "logs_info", "install_config_overrides", "controller_logs_collected_at", "controller_logs_started_at", "connectivity_majority_groups", "ip_collisions", "ignored_host_validations", "ignored_cluster_validations", "deleted_at", "user_managed_networking", "additional_ntp_source", "monitored_operators", "ams_subscription_id", "hyperthreading", "feature_usage", "network_type", "cluster_networks", "service_networks", "machine_networks", "cpu_architecture", "ignition_endpoint", "imported", "tags"]

    @validator('kind')
    def kind_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('Cluster', 'AddHostsCluster'):
            raise ValueError("must be one of enum values ('Cluster', 'AddHostsCluster')")
        return value

    @validator('high_availability_mode')
    def high_availability_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('Full', 'None'):
            raise ValueError("must be one of enum values ('Full', 'None')")
        return value

    @validator('cluster_network_cidr')
    def cluster_network_cidr_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3}\/(?:(?:[0-9])|(?:[1-2][0-9])|(?:3[0-2])))|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,})\/(?:(?:[0-9])|(?:[1-9][0-9])|(?:1[0-1][0-9])|(?:12[0-8])))$", value):
            raise ValueError(r"must validate the regular expression /^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3}\/(?:(?:[0-9])|(?:[1-2][0-9])|(?:3[0-2])))|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,})\/(?:(?:[0-9])|(?:[1-9][0-9])|(?:1[0-1][0-9])|(?:12[0-8])))$/")
        return value

    @validator('service_network_cidr')
    def service_network_cidr_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3}\/(?:(?:[0-9])|(?:[1-2][0-9])|(?:3[0-2])))|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,})\/(?:(?:[0-9])|(?:[1-9][0-9])|(?:1[0-1][0-9])|(?:12[0-8])))$", value):
            raise ValueError(r"must validate the regular expression /^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3}\/(?:(?:[0-9])|(?:[1-2][0-9])|(?:3[0-2])))|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,})\/(?:(?:[0-9])|(?:[1-9][0-9])|(?:1[0-1][0-9])|(?:12[0-8])))$/")
        return value

    @validator('api_vip')
    def api_vip_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3})|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,}))$", value):
            raise ValueError(r"must validate the regular expression /^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3})|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,}))$/")
        return value

    @validator('machine_network_cidr')
    def machine_network_cidr_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3}\/(?:(?:[0-9])|(?:[1-2][0-9])|(?:3[0-2])))|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,})\/(?:(?:[0-9])|(?:[1-9][0-9])|(?:1[0-1][0-9])|(?:12[0-8])))$", value):
            raise ValueError(r"must validate the regular expression /^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3}\/(?:(?:[0-9])|(?:[1-2][0-9])|(?:3[0-2])))|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,})\/(?:(?:[0-9])|(?:[1-9][0-9])|(?:1[0-1][0-9])|(?:12[0-8])))$/")
        return value

    @validator('ingress_vip')
    def ingress_vip_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3})|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,}))$", value):
            raise ValueError(r"must validate the regular expression /^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3})|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,}))$/")
        return value

    @validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in ('insufficient', 'ready', 'error', 'preparing-for-installation', 'pending-for-input', 'installing', 'finalizing', 'installed', 'adding-hosts', 'cancelled', 'installing-pending-user-action'):
            raise ValueError("must be one of enum values ('insufficient', 'ready', 'error', 'preparing-for-installation', 'pending-for-input', 'installing', 'finalizing', 'installed', 'adding-hosts', 'cancelled', 'installing-pending-user-action')")
        return value

    @validator('hyperthreading')
    def hyperthreading_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('masters', 'workers', 'all', 'none'):
            raise ValueError("must be one of enum values ('masters', 'workers', 'all', 'none')")
        return value

    @validator('network_type')
    def network_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('OpenShiftSDN', 'OVNKubernetes'):
            raise ValueError("must be one of enum values ('OpenShiftSDN', 'OVNKubernetes')")
        return value

    @validator('cpu_architecture')
    def cpu_architecture_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('x86_64', 'aarch64', 'arm64', 'ppc64le', 's390x', 'multi'):
            raise ValueError("must be one of enum values ('x86_64', 'aarch64', 'arm64', 'ppc64le', 's390x', 'multi')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Cluster:
        """Create an instance of Cluster from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of image_info
        if self.image_info:
            _dict['image_info'] = self.image_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of platform
        if self.platform:
            _dict['platform'] = self.platform.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in api_vips (list)
        _items = []
        if self.api_vips:
            for _item in self.api_vips:
                if _item:
                    _items.append(_item.to_dict())
            _dict['api_vips'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in ingress_vips (list)
        _items = []
        if self.ingress_vips:
            for _item in self.ingress_vips:
                if _item:
                    _items.append(_item.to_dict())
            _dict['ingress_vips'] = _items
        # override the default output from pydantic by calling `to_dict()` of progress
        if self.progress:
            _dict['progress'] = self.progress.to_dict()
        # override the default output from pydantic by calling `to_dict()` of disk_encryption
        if self.disk_encryption:
            _dict['disk_encryption'] = self.disk_encryption.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in hosts (list)
        _items = []
        if self.hosts:
            for _item in self.hosts:
                if _item:
                    _items.append(_item.to_dict())
            _dict['hosts'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in host_networks (list)
        _items = []
        if self.host_networks:
            for _item in self.host_networks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['host_networks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in monitored_operators (list)
        _items = []
        if self.monitored_operators:
            for _item in self.monitored_operators:
                if _item:
                    _items.append(_item.to_dict())
            _dict['monitored_operators'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in cluster_networks (list)
        _items = []
        if self.cluster_networks:
            for _item in self.cluster_networks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['cluster_networks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in service_networks (list)
        _items = []
        if self.service_networks:
            for _item in self.service_networks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['service_networks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in machine_networks (list)
        _items = []
        if self.machine_networks:
            for _item in self.machine_networks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['machine_networks'] = _items
        # override the default output from pydantic by calling `to_dict()` of ignition_endpoint
        if self.ignition_endpoint:
            _dict['ignition_endpoint'] = self.ignition_endpoint.to_dict()
        # set to None if api_vips (nullable) is None
        # and __fields_set__ contains the field
        if self.api_vips is None and "api_vips" in self.__fields_set__:
            _dict['api_vips'] = None

        # set to None if api_vip_dns_name (nullable) is None
        # and __fields_set__ contains the field
        if self.api_vip_dns_name is None and "api_vip_dns_name" in self.__fields_set__:
            _dict['api_vip_dns_name'] = None

        # set to None if ingress_vips (nullable) is None
        # and __fields_set__ contains the field
        if self.ingress_vips is None and "ingress_vips" in self.__fields_set__:
            _dict['ingress_vips'] = None

        # set to None if host_networks (nullable) is None
        # and __fields_set__ contains the field
        if self.host_networks is None and "host_networks" in self.__fields_set__:
            _dict['host_networks'] = None

        # set to None if vip_dhcp_allocation (nullable) is None
        # and __fields_set__ contains the field
        if self.vip_dhcp_allocation is None and "vip_dhcp_allocation" in self.__fields_set__:
            _dict['vip_dhcp_allocation'] = None

        # set to None if user_managed_networking (nullable) is None
        # and __fields_set__ contains the field
        if self.user_managed_networking is None and "user_managed_networking" in self.__fields_set__:
            _dict['user_managed_networking'] = None

        # set to None if network_type (nullable) is None
        # and __fields_set__ contains the field
        if self.network_type is None and "network_type" in self.__fields_set__:
            _dict['network_type'] = None

        # set to None if cluster_networks (nullable) is None
        # and __fields_set__ contains the field
        if self.cluster_networks is None and "cluster_networks" in self.__fields_set__:
            _dict['cluster_networks'] = None

        # set to None if service_networks (nullable) is None
        # and __fields_set__ contains the field
        if self.service_networks is None and "service_networks" in self.__fields_set__:
            _dict['service_networks'] = None

        # set to None if machine_networks (nullable) is None
        # and __fields_set__ contains the field
        if self.machine_networks is None and "machine_networks" in self.__fields_set__:
            _dict['machine_networks'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Cluster:
        """Create an instance of Cluster from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return Cluster.parse_obj(obj)

        _obj = Cluster.parse_obj({
            "kind": obj.get("kind"),
            "high_availability_mode": obj.get("high_availability_mode") if obj.get("high_availability_mode") is not None else 'Full',
            "id": obj.get("id"),
            "href": obj.get("href"),
            "name": obj.get("name"),
            "user_name": obj.get("user_name"),
            "org_id": obj.get("org_id"),
            "email_domain": obj.get("email_domain"),
            "openshift_version": obj.get("openshift_version"),
            "ocp_release_image": obj.get("ocp_release_image"),
            "openshift_cluster_id": obj.get("openshift_cluster_id"),
            "image_info": ImageInfo.from_dict(obj.get("image_info")) if obj.get("image_info") is not None else None,
            "platform": Platform.from_dict(obj.get("platform")) if obj.get("platform") is not None else None,
            "base_dns_domain": obj.get("base_dns_domain"),
            "cluster_network_cidr": obj.get("cluster_network_cidr"),
            "cluster_network_host_prefix": obj.get("cluster_network_host_prefix"),
            "service_network_cidr": obj.get("service_network_cidr"),
            "api_vip": obj.get("api_vip"),
            "api_vips": [ApiVip.from_dict(_item) for _item in obj.get("api_vips")] if obj.get("api_vips") is not None else None,
            "api_vip_dns_name": obj.get("api_vip_dns_name"),
            "machine_network_cidr": obj.get("machine_network_cidr"),
            "ingress_vip": obj.get("ingress_vip"),
            "ingress_vips": [IngressVip.from_dict(_item) for _item in obj.get("ingress_vips")] if obj.get("ingress_vips") is not None else None,
            "ssh_public_key": obj.get("ssh_public_key"),
            "http_proxy": obj.get("http_proxy"),
            "https_proxy": obj.get("https_proxy"),
            "no_proxy": obj.get("no_proxy"),
            "status": obj.get("status"),
            "status_info": obj.get("status_info"),
            "status_updated_at": obj.get("status_updated_at"),
            "progress": ClusterProgressInfo.from_dict(obj.get("progress")) if obj.get("progress") is not None else None,
            "disk_encryption": DiskEncryption.from_dict(obj.get("disk_encryption")) if obj.get("disk_encryption") is not None else None,
            "hosts": [Host.from_dict(_item) for _item in obj.get("hosts")] if obj.get("hosts") is not None else None,
            "ready_host_count": obj.get("ready_host_count"),
            "enabled_host_count": obj.get("enabled_host_count"),
            "total_host_count": obj.get("total_host_count"),
            "schedulable_masters": obj.get("schedulable_masters") if obj.get("schedulable_masters") is not None else False,
            "schedulable_masters_forced_true": obj.get("schedulable_masters_forced_true") if obj.get("schedulable_masters_forced_true") is not None else True,
            "updated_at": obj.get("updated_at"),
            "created_at": obj.get("created_at"),
            "install_started_at": obj.get("install_started_at"),
            "install_completed_at": obj.get("install_completed_at"),
            "host_networks": [HostNetwork.from_dict(_item) for _item in obj.get("host_networks")] if obj.get("host_networks") is not None else None,
            "pull_secret_set": obj.get("pull_secret_set"),
            "vip_dhcp_allocation": obj.get("vip_dhcp_allocation"),
            "validations_info": obj.get("validations_info"),
            "logs_info": obj.get("logs_info"),
            "install_config_overrides": obj.get("install_config_overrides"),
            "controller_logs_collected_at": obj.get("controller_logs_collected_at"),
            "controller_logs_started_at": obj.get("controller_logs_started_at"),
            "connectivity_majority_groups": obj.get("connectivity_majority_groups"),
            "ip_collisions": obj.get("ip_collisions"),
            "ignored_host_validations": obj.get("ignored_host_validations"),
            "ignored_cluster_validations": obj.get("ignored_cluster_validations"),
            "deleted_at": obj.get("deleted_at"),
            "user_managed_networking": obj.get("user_managed_networking"),
            "additional_ntp_source": obj.get("additional_ntp_source"),
            "monitored_operators": [MonitoredOperator.from_dict(_item) for _item in obj.get("monitored_operators")] if obj.get("monitored_operators") is not None else None,
            "ams_subscription_id": obj.get("ams_subscription_id"),
            "hyperthreading": obj.get("hyperthreading"),
            "feature_usage": obj.get("feature_usage"),
            "network_type": obj.get("network_type"),
            "cluster_networks": [ClusterNetwork.from_dict(_item) for _item in obj.get("cluster_networks")] if obj.get("cluster_networks") is not None else None,
            "service_networks": [ServiceNetwork.from_dict(_item) for _item in obj.get("service_networks")] if obj.get("service_networks") is not None else None,
            "machine_networks": [MachineNetwork.from_dict(_item) for _item in obj.get("machine_networks")] if obj.get("machine_networks") is not None else None,
            "cpu_architecture": obj.get("cpu_architecture") if obj.get("cpu_architecture") is not None else 'x86_64',
            "ignition_endpoint": IgnitionEndpoint.from_dict(obj.get("ignition_endpoint")) if obj.get("ignition_endpoint") is not None else None,
            "imported": obj.get("imported") if obj.get("imported") is not None else False,
            "tags": obj.get("tags")
        })
        return _obj


