# coding: utf-8

"""
    AssistedInstall

    Assisted installation  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, StrictStr, conlist, validator
from openshift_assisted_service.models.boot import Boot
from openshift_assisted_service.models.cpu import Cpu
from openshift_assisted_service.models.disk import Disk
from openshift_assisted_service.models.gpu import Gpu
from openshift_assisted_service.models.interface import Interface
from openshift_assisted_service.models.memory import Memory
from openshift_assisted_service.models.route import Route
from openshift_assisted_service.models.system_vendor import SystemVendor

class Inventory(BaseModel):
    """
    Inventory
    """
    hostname: Optional[StrictStr] = None
    bmc_address: Optional[StrictStr] = None
    interfaces: Optional[conlist(Interface)] = None
    disks: Optional[conlist(Disk)] = None
    boot: Optional[Boot] = None
    system_vendor: Optional[SystemVendor] = None
    bmc_v6address: Optional[StrictStr] = None
    memory: Optional[Memory] = None
    cpu: Optional[Cpu] = None
    gpus: Optional[conlist(Gpu)] = None
    routes: Optional[conlist(Route)] = None
    tpm_version: Optional[StrictStr] = None
    __properties = ["hostname", "bmc_address", "interfaces", "disks", "boot", "system_vendor", "bmc_v6address", "memory", "cpu", "gpus", "routes", "tpm_version"]

    @validator('tpm_version')
    def tpm_version_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('none', '1.2', '2.0'):
            raise ValueError("must be one of enum values ('none', '1.2', '2.0')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Inventory:
        """Create an instance of Inventory from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in interfaces (list)
        _items = []
        if self.interfaces:
            for _item in self.interfaces:
                if _item:
                    _items.append(_item.to_dict())
            _dict['interfaces'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in disks (list)
        _items = []
        if self.disks:
            for _item in self.disks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['disks'] = _items
        # override the default output from pydantic by calling `to_dict()` of boot
        if self.boot:
            _dict['boot'] = self.boot.to_dict()
        # override the default output from pydantic by calling `to_dict()` of system_vendor
        if self.system_vendor:
            _dict['system_vendor'] = self.system_vendor.to_dict()
        # override the default output from pydantic by calling `to_dict()` of memory
        if self.memory:
            _dict['memory'] = self.memory.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cpu
        if self.cpu:
            _dict['cpu'] = self.cpu.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in gpus (list)
        _items = []
        if self.gpus:
            for _item in self.gpus:
                if _item:
                    _items.append(_item.to_dict())
            _dict['gpus'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in routes (list)
        _items = []
        if self.routes:
            for _item in self.routes:
                if _item:
                    _items.append(_item.to_dict())
            _dict['routes'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Inventory:
        """Create an instance of Inventory from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return Inventory.parse_obj(obj)

        _obj = Inventory.parse_obj({
            "hostname": obj.get("hostname"),
            "bmc_address": obj.get("bmc_address"),
            "interfaces": [Interface.from_dict(_item) for _item in obj.get("interfaces")] if obj.get("interfaces") is not None else None,
            "disks": [Disk.from_dict(_item) for _item in obj.get("disks")] if obj.get("disks") is not None else None,
            "boot": Boot.from_dict(obj.get("boot")) if obj.get("boot") is not None else None,
            "system_vendor": SystemVendor.from_dict(obj.get("system_vendor")) if obj.get("system_vendor") is not None else None,
            "bmc_v6address": obj.get("bmc_v6address"),
            "memory": Memory.from_dict(obj.get("memory")) if obj.get("memory") is not None else None,
            "cpu": Cpu.from_dict(obj.get("cpu")) if obj.get("cpu") is not None else None,
            "gpus": [Gpu.from_dict(_item) for _item in obj.get("gpus")] if obj.get("gpus") is not None else None,
            "routes": [Route.from_dict(_item) for _item in obj.get("routes")] if obj.get("routes") is not None else None,
            "tpm_version": obj.get("tpm_version")
        })
        return _obj


