# coding: utf-8

"""
    AssistedInstall

    Assisted installation  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, conlist, constr, validator
from openshift_assisted_service.models.api_vip import ApiVip
from openshift_assisted_service.models.cluster_network import ClusterNetwork
from openshift_assisted_service.models.disk_encryption import DiskEncryption
from openshift_assisted_service.models.ignition_endpoint import IgnitionEndpoint
from openshift_assisted_service.models.ingress_vip import IngressVip
from openshift_assisted_service.models.machine_network import MachineNetwork
from openshift_assisted_service.models.operator_create_params import OperatorCreateParams
from openshift_assisted_service.models.platform import Platform
from openshift_assisted_service.models.service_network import ServiceNetwork

class ClusterCreateParams(BaseModel):
    """
    ClusterCreateParams
    """
    name: constr(strict=True, max_length=54, min_length=1) = Field(..., description="Name of the OpenShift cluster.")
    high_availability_mode: Optional[StrictStr] = Field('Full', description="Guaranteed availability of the installed cluster. 'Full' installs a Highly-Available cluster over multiple master nodes whereas 'None' installs a full cluster over one node. ")
    openshift_version: StrictStr = Field(..., description="Version of the OpenShift cluster.")
    ocp_release_image: Optional[StrictStr] = Field(None, description="OpenShift release image URI.")
    base_dns_domain: Optional[StrictStr] = Field(None, description="Base domain of the cluster. All DNS records must be sub-domains of this base and include the cluster name.")
    cluster_network_cidr: Optional[constr(strict=True)] = Field('10.128.0.0/14', description="IP address block from which Pod IPs are allocated. This block must not overlap with existing physical networks. These IP addresses are used for the Pod network, and if you need to access the Pods from an external network, configure load balancers and routers to manage the traffic.")
    cluster_network_host_prefix: Optional[conint(strict=True, le=128, ge=1)] = Field(None, description="The subnet prefix length to assign to each individual node. For example, if clusterNetworkHostPrefix is set to 23, then each node is assigned a /23 subnet out of the given cidr (clusterNetworkCIDR), which allows for 510 (2^(32 - 23) - 2) pod IPs addresses. If you are required to provide access to nodes from an external network, configure load balancers and routers to manage the traffic.")
    service_network_cidr: Optional[constr(strict=True)] = Field('172.30.0.0/16', description="The IP address pool to use for service IP addresses. You can enter only one IP address pool. If you need to access the services from an external network, configure load balancers and routers to manage the traffic.")
    api_vip: Optional[constr(strict=True)] = Field(None, description="(DEPRECATED) The virtual IP used to reach the OpenShift cluster's API.")
    api_vips: Optional[conlist(ApiVip)] = Field(None, description="The virtual IPs used to reach the OpenShift cluster's API. Enter one IP address for single-stack clusters, or up to two for dual-stack clusters (at most one IP address per IP stack used). The order of stacks should be the same as order of subnets in Cluster Networks, Service Networks, and Machine Networks.")
    ingress_vip: Optional[constr(strict=True)] = Field(None, description="(DEPRECATED) The virtual IP used for cluster ingress traffic.")
    ingress_vips: Optional[conlist(IngressVip)] = Field(None, description="The virtual IPs used for cluster ingress traffic. Enter one IP address for single-stack clusters, or up to two for dual-stack clusters (at most one IP address per IP stack used). The order of stacks should be the same as order of subnets in Cluster Networks, Service Networks, and Machine Networks.")
    pull_secret: StrictStr = Field(..., description="The pull secret obtained from Red Hat OpenShift Cluster Manager at console.redhat.com/openshift/install/pull-secret.")
    ssh_public_key: Optional[StrictStr] = Field(None, description="SSH public key for debugging OpenShift nodes.")
    vip_dhcp_allocation: Optional[StrictBool] = Field(False, description="Indicate if virtual IP DHCP allocation mode is enabled.")
    http_proxy: Optional[StrictStr] = Field(None, description="A proxy URL to use for creating HTTP connections outside the cluster. http://\\<username\\>:\\<pswd\\>@\\<ip\\>:\\<port\\> ")
    https_proxy: Optional[StrictStr] = Field(None, description="A proxy URL to use for creating HTTPS connections outside the cluster. http://\\<username\\>:\\<pswd\\>@\\<ip\\>:\\<port\\> ")
    no_proxy: Optional[StrictStr] = Field(None, description="An \"*\" or a comma-separated list of destination domain names, domains, IP addresses, or other network CIDRs to exclude from proxying.")
    user_managed_networking: Optional[StrictBool] = Field(False, description="(DEPRECATED) Indicate if the networking is managed by the user.")
    additional_ntp_source: Optional[StrictStr] = Field(None, description="A comma-separated list of NTP sources (name or IP) going to be added to all the hosts.")
    olm_operators: Optional[conlist(OperatorCreateParams)] = Field(None, description="List of OLM operators to be installed.")
    hyperthreading: Optional[StrictStr] = Field('all', description="Enable/disable hyperthreading on master nodes, worker nodes, or all nodes.")
    network_type: Optional[StrictStr] = Field(None, description="The desired network type used.")
    schedulable_masters: Optional[StrictBool] = Field(False, description="Schedule workloads on masters")
    cluster_networks: Optional[conlist(ClusterNetwork)] = Field(None, description="Cluster networks that are associated with this cluster.")
    service_networks: Optional[conlist(ServiceNetwork)] = Field(None, description="Service networks that are associated with this cluster.")
    machine_networks: Optional[conlist(MachineNetwork)] = Field(None, description="Machine networks that are associated with this cluster.")
    platform: Optional[Platform] = None
    cpu_architecture: Optional[StrictStr] = Field('x86_64', description="The CPU architecture of the image (x86_64/arm64/etc).")
    disk_encryption: Optional[DiskEncryption] = None
    ignition_endpoint: Optional[IgnitionEndpoint] = None
    tags: Optional[StrictStr] = Field(None, description="A comma-separated list of tags that are associated to the cluster.")
    __properties = ["name", "high_availability_mode", "openshift_version", "ocp_release_image", "base_dns_domain", "cluster_network_cidr", "cluster_network_host_prefix", "service_network_cidr", "api_vip", "api_vips", "ingress_vip", "ingress_vips", "pull_secret", "ssh_public_key", "vip_dhcp_allocation", "http_proxy", "https_proxy", "no_proxy", "user_managed_networking", "additional_ntp_source", "olm_operators", "hyperthreading", "network_type", "schedulable_masters", "cluster_networks", "service_networks", "machine_networks", "platform", "cpu_architecture", "disk_encryption", "ignition_endpoint", "tags"]

    @validator('high_availability_mode')
    def high_availability_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('Full', 'None'):
            raise ValueError("must be one of enum values ('Full', 'None')")
        return value

    @validator('cluster_network_cidr')
    def cluster_network_cidr_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3}\/(?:(?:[0-9])|(?:[1-2][0-9])|(?:3[0-2])))|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,})\/(?:(?:[0-9])|(?:[1-9][0-9])|(?:1[0-1][0-9])|(?:12[0-8])))$", value):
            raise ValueError(r"must validate the regular expression /^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3}\/(?:(?:[0-9])|(?:[1-2][0-9])|(?:3[0-2])))|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,})\/(?:(?:[0-9])|(?:[1-9][0-9])|(?:1[0-1][0-9])|(?:12[0-8])))$/")
        return value

    @validator('service_network_cidr')
    def service_network_cidr_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3}\/(?:(?:[0-9])|(?:[1-2][0-9])|(?:3[0-2])))|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,})\/(?:(?:[0-9])|(?:[1-9][0-9])|(?:1[0-1][0-9])|(?:12[0-8])))$", value):
            raise ValueError(r"must validate the regular expression /^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3}\/(?:(?:[0-9])|(?:[1-2][0-9])|(?:3[0-2])))|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,})\/(?:(?:[0-9])|(?:[1-9][0-9])|(?:1[0-1][0-9])|(?:12[0-8])))$/")
        return value

    @validator('api_vip')
    def api_vip_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3})|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,}))?$", value):
            raise ValueError(r"must validate the regular expression /^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3})|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,}))?$/")
        return value

    @validator('ingress_vip')
    def ingress_vip_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3})|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,}))$", value):
            raise ValueError(r"must validate the regular expression /^(?:(?:(?:[0-9]{1,3}\.){3}[0-9]{1,3})|(?:(?:[0-9a-fA-F]*:[0-9a-fA-F]*){2,}))$/")
        return value

    @validator('hyperthreading')
    def hyperthreading_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('masters', 'workers', 'none', 'all'):
            raise ValueError("must be one of enum values ('masters', 'workers', 'none', 'all')")
        return value

    @validator('network_type')
    def network_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('OpenShiftSDN', 'OVNKubernetes'):
            raise ValueError("must be one of enum values ('OpenShiftSDN', 'OVNKubernetes')")
        return value

    @validator('cpu_architecture')
    def cpu_architecture_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in ('x86_64', 'aarch64', 'arm64', 'ppc64le', 's390x', 'multi'):
            raise ValueError("must be one of enum values ('x86_64', 'aarch64', 'arm64', 'ppc64le', 's390x', 'multi')")
        return value

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> ClusterCreateParams:
        """Create an instance of ClusterCreateParams from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of each item in api_vips (list)
        _items = []
        if self.api_vips:
            for _item in self.api_vips:
                if _item:
                    _items.append(_item.to_dict())
            _dict['api_vips'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in ingress_vips (list)
        _items = []
        if self.ingress_vips:
            for _item in self.ingress_vips:
                if _item:
                    _items.append(_item.to_dict())
            _dict['ingress_vips'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in olm_operators (list)
        _items = []
        if self.olm_operators:
            for _item in self.olm_operators:
                if _item:
                    _items.append(_item.to_dict())
            _dict['olm_operators'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in cluster_networks (list)
        _items = []
        if self.cluster_networks:
            for _item in self.cluster_networks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['cluster_networks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in service_networks (list)
        _items = []
        if self.service_networks:
            for _item in self.service_networks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['service_networks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in machine_networks (list)
        _items = []
        if self.machine_networks:
            for _item in self.machine_networks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['machine_networks'] = _items
        # override the default output from pydantic by calling `to_dict()` of platform
        if self.platform:
            _dict['platform'] = self.platform.to_dict()
        # override the default output from pydantic by calling `to_dict()` of disk_encryption
        if self.disk_encryption:
            _dict['disk_encryption'] = self.disk_encryption.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ignition_endpoint
        if self.ignition_endpoint:
            _dict['ignition_endpoint'] = self.ignition_endpoint.to_dict()
        # set to None if vip_dhcp_allocation (nullable) is None
        # and __fields_set__ contains the field
        if self.vip_dhcp_allocation is None and "vip_dhcp_allocation" in self.__fields_set__:
            _dict['vip_dhcp_allocation'] = None

        # set to None if http_proxy (nullable) is None
        # and __fields_set__ contains the field
        if self.http_proxy is None and "http_proxy" in self.__fields_set__:
            _dict['http_proxy'] = None

        # set to None if https_proxy (nullable) is None
        # and __fields_set__ contains the field
        if self.https_proxy is None and "https_proxy" in self.__fields_set__:
            _dict['https_proxy'] = None

        # set to None if no_proxy (nullable) is None
        # and __fields_set__ contains the field
        if self.no_proxy is None and "no_proxy" in self.__fields_set__:
            _dict['no_proxy'] = None

        # set to None if user_managed_networking (nullable) is None
        # and __fields_set__ contains the field
        if self.user_managed_networking is None and "user_managed_networking" in self.__fields_set__:
            _dict['user_managed_networking'] = None

        # set to None if additional_ntp_source (nullable) is None
        # and __fields_set__ contains the field
        if self.additional_ntp_source is None and "additional_ntp_source" in self.__fields_set__:
            _dict['additional_ntp_source'] = None

        # set to None if network_type (nullable) is None
        # and __fields_set__ contains the field
        if self.network_type is None and "network_type" in self.__fields_set__:
            _dict['network_type'] = None

        # set to None if cluster_networks (nullable) is None
        # and __fields_set__ contains the field
        if self.cluster_networks is None and "cluster_networks" in self.__fields_set__:
            _dict['cluster_networks'] = None

        # set to None if service_networks (nullable) is None
        # and __fields_set__ contains the field
        if self.service_networks is None and "service_networks" in self.__fields_set__:
            _dict['service_networks'] = None

        # set to None if machine_networks (nullable) is None
        # and __fields_set__ contains the field
        if self.machine_networks is None and "machine_networks" in self.__fields_set__:
            _dict['machine_networks'] = None

        # set to None if tags (nullable) is None
        # and __fields_set__ contains the field
        if self.tags is None and "tags" in self.__fields_set__:
            _dict['tags'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> ClusterCreateParams:
        """Create an instance of ClusterCreateParams from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return ClusterCreateParams.parse_obj(obj)

        _obj = ClusterCreateParams.parse_obj({
            "name": obj.get("name"),
            "high_availability_mode": obj.get("high_availability_mode") if obj.get("high_availability_mode") is not None else 'Full',
            "openshift_version": obj.get("openshift_version"),
            "ocp_release_image": obj.get("ocp_release_image"),
            "base_dns_domain": obj.get("base_dns_domain"),
            "cluster_network_cidr": obj.get("cluster_network_cidr") if obj.get("cluster_network_cidr") is not None else '10.128.0.0/14',
            "cluster_network_host_prefix": obj.get("cluster_network_host_prefix"),
            "service_network_cidr": obj.get("service_network_cidr") if obj.get("service_network_cidr") is not None else '172.30.0.0/16',
            "api_vip": obj.get("api_vip"),
            "api_vips": [ApiVip.from_dict(_item) for _item in obj.get("api_vips")] if obj.get("api_vips") is not None else None,
            "ingress_vip": obj.get("ingress_vip"),
            "ingress_vips": [IngressVip.from_dict(_item) for _item in obj.get("ingress_vips")] if obj.get("ingress_vips") is not None else None,
            "pull_secret": obj.get("pull_secret"),
            "ssh_public_key": obj.get("ssh_public_key"),
            "vip_dhcp_allocation": obj.get("vip_dhcp_allocation") if obj.get("vip_dhcp_allocation") is not None else False,
            "http_proxy": obj.get("http_proxy"),
            "https_proxy": obj.get("https_proxy"),
            "no_proxy": obj.get("no_proxy"),
            "user_managed_networking": obj.get("user_managed_networking") if obj.get("user_managed_networking") is not None else False,
            "additional_ntp_source": obj.get("additional_ntp_source"),
            "olm_operators": [OperatorCreateParams.from_dict(_item) for _item in obj.get("olm_operators")] if obj.get("olm_operators") is not None else None,
            "hyperthreading": obj.get("hyperthreading") if obj.get("hyperthreading") is not None else 'all',
            "network_type": obj.get("network_type"),
            "schedulable_masters": obj.get("schedulable_masters") if obj.get("schedulable_masters") is not None else False,
            "cluster_networks": [ClusterNetwork.from_dict(_item) for _item in obj.get("cluster_networks")] if obj.get("cluster_networks") is not None else None,
            "service_networks": [ServiceNetwork.from_dict(_item) for _item in obj.get("service_networks")] if obj.get("service_networks") is not None else None,
            "machine_networks": [MachineNetwork.from_dict(_item) for _item in obj.get("machine_networks")] if obj.get("machine_networks") is not None else None,
            "platform": Platform.from_dict(obj.get("platform")) if obj.get("platform") is not None else None,
            "cpu_architecture": obj.get("cpu_architecture") if obj.get("cpu_architecture") is not None else 'x86_64',
            "disk_encryption": DiskEncryption.from_dict(obj.get("disk_encryption")) if obj.get("disk_encryption") is not None else None,
            "ignition_endpoint": IgnitionEndpoint.from_dict(obj.get("ignition_endpoint")) if obj.get("ignition_endpoint") is not None else None,
            "tags": obj.get("tags")
        })
        return _obj


